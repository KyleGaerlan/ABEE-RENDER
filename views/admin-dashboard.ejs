<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard</title>
    <link rel="stylesheet" href="/css/useradmin.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    
    <style>
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .dashboard-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .dashboard-card h2 {
            margin-top: 0;
            color: #333;
            font-size: 1.2rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            grid-column: span 6;
        }

        .chart-container h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.1rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .chart-container.full-width {
            grid-column: span 12;
        }

        .chart-container.medium-width {
            grid-column: span 4;
        }

        .card-content {
            margin-top: 15px;
            flex-grow: 1;
            overflow-y: auto;
            max-height: 200px;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #refreshData {
            padding: 8px 15px;
            background-color: #f26523;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        #refreshData:hover {
            background-color: #d55a1f;
        }

        .last-updated {
            font-size: 0.9em;
            color: #666;
        }

        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #dc3545;
            color: white;
            padding: 15px 25px;
            border-radius: 4px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .destinations-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .destinations-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .destinations-list li:last-child {
            border-bottom: none;
        }
        
        .destination-name {
            font-weight: 500;
        }
        
        .destination-count {
            color: #f26523;
            font-weight: 600;
        }

        .analytics-section {
            margin-bottom: 30px;
        }

        .analytics-section h2 {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #f26523;
            padding-bottom: 8px;
            display: inline-block;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 15px;
    text-align: center;
    border-left: 4px solid #f26523;
    display: flex;
    flex-direction: column;
}

.stat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.stat-header h3 {
    margin: 0;
    font-size: 0.9rem;
    color: #666;
    text-align: left;
}

.period-selector {
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid #ddd;
    font-size: 0.8rem;
}


        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 10px 0;
            color: #333;
        }

        .stat-trend {
            font-size: 0.8rem;
            color: #28a745;
        }

        .stat-trend.negative {
            color: #dc3545;
        }

        .chart-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .chart-tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
            background-color: #f8f9fa;
        }

        .chart-tab.active {
            background-color: white;
            border-color: #ddd;
            border-bottom-color: white;
            margin-bottom: -1px;
            font-weight: 500;
        }

        .chart-tab-content {
            display: none;
        }

        .chart-tab-content.active {
            display: block;
        }
        /* Improved menu toggle button */
.menu-toggle {
    display: none;
    position: fixed;
    top: 15px;
    left: 15px;
    z-index: 1000;
    background-color: #f26523;
    color: white;
    border: none;
    border-radius: 4px;
    width: 40px;
    height: 40px;
    cursor: pointer;
    padding: 0;
}

.menu-toggle-inner {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.menu-toggle span {
    display: block;
    position: absolute;
    width: 22px;
    height: 2px;
    background-color: white;
    transition: all 0.3s ease;
    left: 9px; /* Centered within the 40px button */
}

.menu-toggle span:nth-child(1) {
    top: 14px;
}

.menu-toggle span:nth-child(2) {
    top: 19px;
}

.menu-toggle span:nth-child(3) {
    top: 24px;
}

.menu-toggle.active span:nth-child(1) {
    transform: rotate(45deg);
    top: 19px;
}

.menu-toggle.active span:nth-child(2) {
    opacity: 0;
}

.menu-toggle.active span:nth-child(3) {
    transform: rotate(-45deg);
    top: 19px;
}

.sidebar-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 998;
}

@media (max-width: 768px) {
    .menu-toggle {
        display: block;
    }

    .sidebar {
        position: fixed;
        left: -250px;
        top: 0;
        height: 100%;
        width: 250px;
        z-index: 999;
        transition: left 0.3s ease;
        overflow-y: auto;
    }

    .sidebar.active {
        left: 0;
    }

    .main-content {
        margin-left: 0;
        width: 100%;
        padding: 20px;
        padding-top: 60px;
    }

    .sidebar-overlay.active {
        display: block;
    }
}
.detailed-list li {
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}

.detailed-list li:last-child {
    border-bottom: none;
}

.list-date {
    font-weight: bold;
    color: #333;
}

.list-time {
    color: #666;
    font-size: 0.9em;
    margin-left: 5px;
}

.list-count {
    color: #f26523;
    font-weight: bold;
}
.export-buttons {
    display: flex;
    gap: 10px;
    margin-right: 15px;
}

.action-button {
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 5px;
}

.export-button {
    background-color: #28a745;
    color: white;
}

.export-button:hover {
    background-color: #218838;
}

.print-button {
    background-color: #17a2b8;
    color: white;
}

.print-button:hover {
    background-color: #138496;
}

@media print {
    .sidebar, .menu-toggle, .sidebar-overlay, .header-actions, .no-print {
        display: none !important;
    }
    
    .main-content {
        margin-left: 0 !important;
        padding: 0 !important;
        width: 100% !important;
    }
    
    body {
        background-color: white !important;
    }
    
    .dashboard-grid, .chart-grid {
        page-break-inside: avoid;
    }
    
    .dashboard-card, .chart-container {
        break-inside: avoid;
        box-shadow: none !important;
        border: 1px solid #ddd !important;
    }
    
    .print-header {
        display: block !important;
        text-align: center;
        margin-bottom: 20px;
    }
    
    .print-footer {
        display: block !important;
        text-align: center;
        margin-top: 20px;
        font-size: 12px;
        color: #666;
    }
}

.print-header, .print-footer {
    display: none;
}
.notification.success {
    background-color: #28a745;
    color: white;
    padding: 15px 25px;
    border-radius: 4px;
    z-index: 1000;
    animation: slideIn 0.3s ease-out;
}

.notification.error {
    background-color: #dc3545;
    color: white;
    padding: 15px 25px;
    border-radius: 4px;
    z-index: 1000;
    animation: slideIn 0.3s ease-out;
}
.chart-container.full-width {
    grid-column: span 12;
    height: 400px; /* Increase the height */
}

.chart-container {
    grid-column: span 12; /* Make all charts full width */
    height: 400px; /* Increase the height */
}.analytics-controls {
    margin-bottom: 20px;
}

.analytics-selector {
    padding: 8px 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
    background-color: white;
    cursor: pointer;
}

.analytics-selector:focus {
    outline: none;
    border-color: #f26523;
}

.analytics-content {
    transition: opacity 0.3s ease;
}
/* Update these CSS rules in your existing styles */

.chart-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-bottom: 20px;
    width: 100%;
}

.chart-container {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 20px;
    position: relative;
    width: 80%;
    height: 600px; /* Fixed height for all charts */
}

.chart-container.full-width {
    grid-column: 1 / -1; /* Span all columns */
}

.chart-container canvas {
    width: 100% !important;
    height: 100% !important;
}

.analytics-content {
    margin-top: 20px;
    width: 100%;
}

/* Add responsive breakpoints */
@media (max-width: 1200px) {
    .chart-grid {
        grid-template-columns: 1fr; /* Single column on smaller screens */
    }
    
    .chart-container {
        height: 350px; /* Slightly smaller height on mobile */
    }
}

.predictive-analytics {
  margin-top: 3rem;
  padding: 2rem;
  background-color: #f9fafc;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

.predictive-analytics h2 {
  margin-bottom: 1rem;
  color: #333;
}

.chart-card {
  background: #fff;
  border-radius: 10px;
  padding: 1rem;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  margin-bottom: 1.5rem;
}
.forecast-section {
  margin-top: 30px;
  background: #fff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.forecast-metrics {
  background: #f8f9fa;
  padding: 15px;
  border-radius: 10px;
  font-size: 14px;
}

    </style>
    <style>
  .forecast-summary {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
  }
  .forecast-card {
    flex: 1;
    background: #fff;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    text-align: center;
  }
  .forecast-card h3 {
    font-size: 1rem;
    margin-bottom: 8px;
  }
    .forecast-charts canvas {
    width: 100%;
    height: 300px;
    margin-top: 25px;
  }
</style>
<style>
  .forecast-section + div.bg-gray-50 {
    margin-top: 30px;
  }
</style>
 <style>
    body {
      font-family: 'Poppins', sans-serif;
      background-color: #f5f7fb;
      color: #333;
    }

    .dashboard {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    h1 {
      font-size: 1.8rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    section {
      margin-bottom: 3rem;
    }

    .forecast-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #fff;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      margin-bottom: 15px;
    }

    .forecast-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    canvas {
      max-width: 100%;
      margin: 15px 0;
    }

    .text-red-500 { color: #dc2626; }
    .text-green-500 { color: #16a34a; }
    .text-orange-500 { color: #f97316; }
    .ai-forecast-section {
  margin-top: 2.5rem;
  background: #fff;
  border-radius: 1rem;
  padding: 1.5rem;
  box-shadow: 0 1px 6px rgba(0,0,0,0.1);
}
.insight-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}
.insight-card {
  background: #f8fafc;
  border-radius: 0.75rem;
  padding: 1rem;
  text-align: center;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}
.insight-card h3 {
  font-size: 1rem;
  color: #333;
  margin-bottom: 0.5rem;
}
.insight-card p {
  font-size: 1.5rem;
  font-weight: bold;
  color: #d55a1f;
}
.chart-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 1.5rem;
  align-items: start; /* Prevent stretch */
}

/* üß± Ensure chart containers keep natural height */
.chart-container {
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 1rem;
  padding: 1rem;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
  height: auto;
  min-height: 360px; /* Enough for charts but not oversized */
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.chart-container canvas {
  flex-grow: 1;
  max-height: 340px;
}
.recommendations {
  background: #f9f9f9;
  border-radius: 0.75rem;
  padding: 1rem;
  font-size: 0.95rem;
  line-height: 1.4;
}
.text-muted {
  color: #6b7280;
}
.mt-6 {
  margin-top: 1.5rem;
}
.user-engagement {
  background: #fff;
  padding: 1.5rem;
  border-radius: 1rem;
  box-shadow: 0 1px 5px rgba(0,0,0,0.08);
  margin-top: 1.5rem;
}

.engagement-grid {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

.engagement-card {
  flex: 1;
  min-width: 200px;
  background: #f8fafc;
  padding: 1rem;
  border-radius: 0.75rem;
  text-align: center;
}

.engagement-card h3 {
  font-size: 1rem;
  margin-bottom: 0.25rem;
  color: #333;
}

.engagement-card p {
  font-size: 1.5rem;
  font-weight: bold;
  color: #d55a1f;
}
.user-activity {
  background: #fff;
  padding: 1.5rem;
  border-radius: 1rem;
  margin-top: 1.5rem;
  box-shadow: 0 1px 5px rgba(0,0,0,0.08);
}
.user-activity-summary {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}
.user-activity-summary div {
  background: #f8fafc;
  padding: 0.75rem 1rem;
  border-radius: 0.5rem;
}
.user-activity-lists {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.activity-card {
  flex: 1;
  min-width: 300px;
  background: #f8fafc;
  padding: 1rem;
  border-radius: 0.75rem;
}
.activity-card ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
.activity-card li {
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
}
.selector-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 1rem;
}

.destination-select {
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid #ccc;
  font-size: 14px;
}
.export-btn {
  background-color: #f26523;
  color: white;
  border: none;
  padding: 10px 16px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: 0.2s;
}
.export-btn:hover {
  background-color: #d8561f;
}

  </style>
  
</head>
<body>
    <button class="menu-toggle" id="menuToggle">
        <div class="menu-toggle-inner">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </button>
    
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <div class="sidebar" id="sidebar">
        <div class="logo">
            <img src="/images/Image-logo.png" alt="Company Logo">
        </div>
        <div class="admin-info" style="display: none;">
            <p>Welcome, <span id="adminName"><%= admin.firstName %> <%= admin.lastName %></span></p>
            <p class="admin-role" id="adminRole">Role: <%= admin.role %></p>
        </div>
        <nav class="sidebar-nav">
           <a href="/admin-dashboard">Dashboard</a>
            <% if (admin.role !== 'employee') { %>
                <a href="/admin-users">Users</a>
                <a href="/admin-approvals">Account Approvals</a>
            <% } %>
            <a href="/employee-dashboard">Employee Performance</a>
            
            <a href="/admin-bookings">Bookings</a>
            <a href="/admin-tours">Tours</a>
            <a href="/admin-messages">Messages</a>
            <a href="#" onclick="handleAdminLogout()">Logout</a>
        </nav>   
    </div>
    

    <div class="main-content">
        <header class="dashboard-header">
            <h1>Admin Dashboard</h1>
            <div class="header-actions">
                <div class="export-buttons">
                    <button id="printDashboard" class="action-button print-button">
                        <i class="fas fa-print"></i> Print Dashboard
                    </button>
                    <button id="exportCSV" class="action-button export-button">
                        <i class="fas fa-file-csv"></i> Export to CSV
                    </button>
                <button id="exportDashboardExcel" class="export-btn">üì§ Export Dashboard Report</button>
          </div>
                
                <div class="last-updated">Last updated: <span id="lastUpdated">Never</span></div>
            </div>
        </header>
        
        <div class="stats-summary">
            <div class="stat-card">
                <div class="stat-header">
                    <h3>Total Registered Users</h3>
                    <select id="usersPeriod" class="period-selector">
                        <option value="all">All Time</option>
                        <option value="year">This Year</option>
                        <option value="month">This Month</option>
                        <option value="day">Today</option>
                    </select>
                </div>
                <div class="stat-value" id="totalUsers">--</div>
            </div>
            <div class="stat-card">
                 <div class="stat-header">
                    <h3>Total Bookings</h3>
                    <select id="bookingsPeriod" class="period-selector">
                        <option value="all">All Time</option>
                        <option value="year">This Year</option>
                        <option value="month">This Month</option>
                        <option value="day">Today</option>
                    </select>
                </div>
                <div class="stat-value" id="totalBookings">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-header">
                    <h3>Total Sales</h3>
                    <select id="salesPeriod" class="period-selector">
                        <option value="all">All Time</option>
                        <option value="year">This Year</option>
                        <option value="month">This Month</option>
                        <option value="day">Today</option>
                    </select>
                </div>
                <div class="stat-value" id="totalRevenue">‚Ç±--</div>
            </div>
        </div>

        <div class="analytics-section">

            <h2>Recent Activity</h2>
            <div class="dashboard-grid">
                <div class="dashboard-card">
                    <h2>Users This Week</h2>
                    <div class="card-content">
                        <ul id="user-list" class="detailed-list"><p>Loading...</p></ul>
                    </div>
                </div>                

                 <div class="dashboard-card">
                    <h2>Bookings This Week</h2>
                    <div class="card-content">
                        <ul id="booking-list" class="detailed-list"><p>Loading...</p></ul>
                    </div>
                </div>                
                
                <div class="dashboard-card">
                    <div class="stat-header">
                        <h2>Top Destinations</h2>
                        <select id="destinationsPeriod" class="period-selector">
                            <option value="all">All Time</option>
                            <option value="year">This Year</option>
                            <option value="month">This Month</option>
                            <option value="day">Today</option>
                        </select>
                    </div>
                    <div class="card-content">
                        <ul id="destinations-list" class="destinations-list"><p>Loading...</p></ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="analytics-section">
            <h2>Time-Based Analytics</h2>
            <div class="chart-tabs">
                <div class="chart-tab active" data-period="weekly">Weekly</div>
                <div class="chart-tab" data-period="monthly">Monthly</div>
                <div class="chart-tab" data-period="yearly">Yearly</div>
            </div>
           <div class="weekly-selector chart-tab-content active">
  <label for="weekly-month">Select Month:</label>
  <select id="weekly-month">
    <option value="0">January</option>
    <option value="1">February</option>
    <option value="2">March</option>
    <option value="3">April</option>
    <option value="4">May</option>
    <option value="5">June</option>
    <option value="6">July</option>
    <option value="7">August</option>
    <option value="8">September</option>
    <option value="9">October</option>
    <option value="10">November</option>
    <option value="11">December</option>
  </select>

  <label for="weekly-year">Year:</label>
  <select id="weekly-year"></select>

  <button id="weekly-apply-range" class="action-button" style="background-color:#d55a1f;color:white">
    Apply
  </button>
</div>

                
                <div class="monthly-selector chart-tab-content">
                    <label for="monthly-year">Select Year:</label>
                    <select id="monthly-year"></select>
                    <button id="monthly-apply" class="action-button" style="background-color: #d55a1f; color:white">Apply</button>
                </div>
                <div class="yearly-selector chart-tab-content">
                    <label for="yearly-future-years">Future Years to Show:</label>
                    <select id="yearly-future-years">
                        <option value="0">None</option>
                        <option value="1">1 Year</option>
                        <option value="2">2 Years</option>
                        <option value="3">3 Years</option>
                        <option value="5" selected>5 Years</option>
                        <option value="10">10 Years</option>
                    </select>
                    <button id="yearly-apply" class="action-button"style="background-color: #d55a1f; color:white">Apply</button>
                </div>
                
            </div>
            
            <div class="chart-grid">
                <div class="chart-container full-width">
                    <h3>User Registrations</h3>
                    <canvas id="timeBasedUsersChart"></canvas>
                </div>
                
                <div class="chart-container full-width">
                    <h3>Bookings</h3>
                    <canvas id="timeBasedBookingsChart"></canvas>
                </div>
                
                <div class="chart-container full-width">
                    <h3>Sales</h3>
                    <canvas id="timeBasedRevenueChart"></canvas>
                </div>
                
            </div>
       
<div class="mt-6 bg-gray-50 border border-gray-200 rounded-2xl p-4 shadow-sm">
<h1>üìä Admin Forecast Dashboard</h1>
  <!-- ‚úÖ FORECAST SUMMARY CARDS -->
<div class="forecast-summary">
  <div class="forecast-card">
    <h3>üí∞ Projected Sales (Next 30 Days)</h3>
    <p id="projectedSales">‚Ç±--</p>
  </div>
  <div class="forecast-card">
    <h3>üß≥ Projected Bookings</h3>
    <p id="projectedBookings">--</p>
  </div>
</div>
</div>
<div class="dashboard">

    <section>
      <div class="forecast-card">
        <h3>üí∞ Sales Forecast</h3>
        <p id="salesForecastAccuracy">MAPE: -- | RMSE: --</p>
        <p id="salesForecastNote" class="text-orange-500" style="display: none;">Loading...</p>
      </div>
      <canvas id="salesForecastChart" height="120"></canvas>
    </section>

    <!-- 2Ô∏è‚É£ USER FORECAST -->
    <section>
      <div class="forecast-card">
        <h3>üë• User Forecast</h3>
        <p id="userForecastAccuracy">MAPE: -- | RMSE: --</p>
        <p id="userForecastNote" class="text-orange-500" style="display: none;">Loading...</p>
      </div>
      <canvas id="userForecastChart" height="120"></canvas>
    </section>

    <!-- 3Ô∏è‚É£ BOOKING FORECAST -->
    <section>
      <div class="forecast-card">
        <h3>üß≥ Booking Forecast</h3>
        <p id="bookingForecastAccuracy">MAPE: -- | RMSE: --</p>
        <p id="bookingForecastNote" class="text-orange-500" style="display: none;">Loading...</p>

      </div>
      <canvas id="bookingForecastChart" height="120"></canvas>
    </section>

<!-- =============================================== -->
<!-- üîÆ AI-Driven Forecast & Decision Analytics -->
<!-- =============================================== -->
<section class="ai-forecast-section">
  <h2>Predictive Insights Dashboard</h2>

  <!-- üìä 1Ô∏è‚É£ Forecast Insight Cards -->
  <div class="insight-grid">
    <div class="insight-card">
      <h3>üí∞ Projected Sales</h3>
      <p id="projectedTotalSales">‚Ç±--</p>
      <small id="salesGrowthNote" class="text-muted">Loading...</small>
    </div>

    <div class="insight-card">
      <h3>üß≥ Expected Bookings</h3>
      <p id="projectedTotalBookings">--</p>
      <small id="bookingsTrendNote" class="text-muted">Loading...</small>
    </div>

    <div class="insight-card">
      <h3>üë• New Users Forecast</h3>
      <p id="projectedTotalUsers">--</p>
      <small id="userGrowthNote" class="text-muted">Loading...</small>
    </div>


  </div>

  <!-- üß† 2Ô∏è‚É£ Decision Support Section -->
  <section class="decision-support mt-6">
    <h3>üß† AI Recommendations</h3>
    <div id="aiRecommendations" class="recommendations">
      <p>Analyzing trends and generating recommendations...</p>
    </div>
  </section>

  <!-- üìà 3Ô∏è‚É£ Comparison & Trend Charts -->
  <section class="trend-comparison mt-6">
    <h3>üìä Trend & Performance Comparison</h3>
    <div class="chart-grid">
      <div class="chart-container">
        <h4>Sales vs Bookings Growth</h4>
        <canvas id="growthComparisonChart"></canvas>
      </div>
      <div class="chart-container">
        <h4>Top 5 Tours</h4>
        <canvas id="topToursChart"></canvas>
      </div>
      <div class="chart-container">
  <h4>üå± Emerging vs ‚ö†Ô∏è Declining Tours</h4>
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
    <div class="bg-green-50 border border-green-200 rounded-xl p-4 shadow-sm">
      <h5 class="text-green-700 font-semibold mb-2">üå± Emerging Tours</h5>
      <ul id="emergingToursList" class="text-green-800 text-sm list-disc pl-4">
        <li>Loading...</li>
      </ul>
    </div>
    <div class="bg-red-50 border border-red-200 rounded-xl p-4 shadow-sm">
      <h5 class="text-red-700 font-semibold mb-2">‚ö†Ô∏è Declining Tours</h5>
      <ul id="decliningToursList" class="text-red-800 text-sm list-disc pl-4">
        <li>Loading...</li>
      </ul>
    </div>
  </div>
</div>

    </div>
  </section>
<!-- ‚òÄÔ∏è 4Ô∏è‚É£ Seasonal Demand Forecast -->
<section class="seasonal-insights mt-6">
  <h3>‚òÄÔ∏è Peak Season Predictions</h3>

  <!-- üìç New Summary Line -->
  <p id="peakSeasonSummary" class="text-gray-600 text-sm mt-1"></p>

  <!-- Dropdown for destinations -->
  <select id="destinationSelect" class="mt-2 mb-3 p-2 border rounded"></select>

  <div class="chart-container full-width">
    <canvas id="seasonalDemandChart"></canvas>
  </div>
</section>
  
<!-- üë• USER ENGAGEMENT SUMMARY -->
<div class="analytics-section user-engagement">
  <h2>üë• User Engagement Summary</h2>
  <div class="engagement-grid">
    <div class="engagement-card">
      <h3>üü¢ Active in Last 7 Days</h3>
      <p id="activeUsers7">--</p>
    </div>
    <div class="engagement-card">
      <h3>üü† Active in Last 30 Days</h3>
      <p id="activeUsers30">--</p>
    </div>
    <div class="engagement-card">
      <h3>üîÅ Retention Rate</h3>
      <p id="retentionRate">--%</p>
    </div>
  </div>
</div>
<!-- üìä USER ENGAGEMENT TREND CHART -->
<section class="user-engagement-trend mt-6">
  <h3>üìä Active Users & Retention Trend</h3>
  <div class="chart-container full-width">
    <canvas id="userEngagementTrendChart"></canvas>
  </div>
</section>
<!-- üë• USER ACTIVITY INSIGHTS -->
<div class="analytics-section user-activity">
  <h2>üë• User Activity Insights</h2>
  <div class="user-activity-summary">
    <div><strong>Total Users:</strong> <span id="activityTotalUsers">--</span></div>
    <div><strong>Active (7 days):</strong> <span id="activityActiveCount">--</span></div>
    <div><strong>Inactive (30+ days):</strong> <span id="activityInactiveCount">--</span></div>
  </div>

  <div class="user-activity-lists">
    <div class="activity-card">
      <h3>üî• Most Active Users</h3>
      <ul id="mostActiveUsers" class="detailed-list"></ul>
    </div>
    <div class="activity-card">
      <h3>üò¥ Inactive Users (30+ Days)</h3>
      <ul id="inactiveUsers" class="detailed-list"></ul>
    </div>
  </div>
</div>
<!-- üå§ SEASONAL ANALYTICS (ACTUAL vs PROPHET PREDICTED) -->
<section class="analytics-section seasonal-analytics mt-8">
  <h2>üå§ Seasonal Analytics (Actual vs Predicted)</h2>
  <p class="text-gray-600 mb-3">
    Compare historical booking trends with AI-based Prophet predictions for the selected year.
  </p>

  <!-- Year Selection -->
  <div class="analytics-controls mb-4">
    <label for="seasonal-year" class="font-medium">Select Year:</label>
    <select id="seasonal-year" class="ml-2 border rounded px-2 py-1"></select>
    <button id="seasonal-apply" class="action-button ml-2" style="background-color: #d55a1f; color:white;">
      Apply
    </button>
  </div>

  <!-- Chart Grid -->
  <div class="chart-grid">
    <div class="chart-container full-width" style="width: 100%; height: 90%;">
      <h3>üìä Actual Bookings per Month</h3>
      <canvas id="seasonalTrendsChart"></canvas>
    </div>

    <div class="chart-container full-width" style="width: 100%; height: 90%;">
      <h3 id="predictedBookingsTitle">üîÆ Forecasted Bookings for Next Year</h3>
      <canvas id="predictedBookingsChart"></canvas>
    </div>
  </div>
</section>

        </div>
        
        </div>
        
        
        

        <div class="print-header">
            <h1>A.BEE Travel and Tours - Admin Dashboard Report</h1>
            <p>Generated on: <span id="printDate"></span></p>
        </div>
        
        <!-- At the end of main-content, before closing div -->
        <div class="print-footer">
            <p>¬© A.BEE Travel and Tours - Confidential Admin Report</p>
        </div>
        
    </div>

    <script>
        let userChart = null;
        let bookingChart = null;
        let destinationChart = null;
        let revenueChart = null;
        let userTrendsChart = null;
        let paymentMethodsChart = null;

        document.addEventListener('DOMContentLoaded', async function() {
    const adminName = localStorage.getItem('adminName') || 'Admin';
    const adminRole = localStorage.getItem('adminRole') || 'admin';

    document.getElementById('adminName').textContent = adminName;
    document.getElementById('adminRole').textContent = `Role: ${adminRole}`;

    // ‚úÖ Force all dropdowns to "All Time" before fetching data
    ['usersPeriod', 'bookingsPeriod', 'salesPeriod', 'destinationsPeriod'].forEach(id => {
        const select = document.getElementById(id);
        if (select) select.value = 'all';
    });

    // ‚úÖ Wait briefly so the DOM updates before calling fetch
    await new Promise(r => setTimeout(r, 150));

    // ‚úÖ Now fetch everything using "All Time"
    await fetchDashboardData();
    await fetchSummaryData();

    // ‚úÖ Add listeners for dropdown changes
    ['usersPeriod', 'bookingsPeriod', 'salesPeriod', 'destinationsPeriod'].forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            select.addEventListener('change', fetchSummaryData);
        }
    });
});



        async function fetchSummaryData() {
            try {
                const usersPeriod = document.getElementById('usersPeriod').value;
                const bookingsPeriod = document.getElementById('bookingsPeriod').value;
                const salesPeriod = document.getElementById('salesPeriod').value;
                const destinationsPeriod = document.getElementById('destinationsPeriod').value;

                // Fetch data for each card based on its own selector
                const usersResponse = await fetch(`/api/analytics/summary?period=${usersPeriod}`);
                const usersData = await usersResponse.json();
                if(usersData.success) document.getElementById('totalUsers').textContent = usersData.data.totalUsers.toLocaleString();

                const bookingsResponse = await fetch(`/api/analytics/summary?period=${bookingsPeriod}`);
                const bookingsData = await bookingsResponse.json();
                if(bookingsData.success) document.getElementById('totalBookings').textContent = bookingsData.data.totalBookings.toLocaleString();

                const salesResponse = await fetch(`/api/analytics/summary?period=${salesPeriod}`);
                const salesData = await salesResponse.json();
                if(salesData.success) document.getElementById('totalRevenue').textContent = '‚Ç±' + salesData.data.totalSales.toLocaleString();

                const destinationsResponse = await fetch(`/api/analytics/summary?period=${destinationsPeriod}`);
                const destinationsData = await destinationsResponse.json();
                if(destinationsData.success) {
                    const destinationsList = document.getElementById('destinations-list');
                    if (destinationsData.data.topDestinations && destinationsData.data.topDestinations.length > 0) {
                        destinationsList.innerHTML = destinationsData.data.topDestinations.map(item => 
                            `<li>
                                <span class="destination-name">${item._id || 'Unknown'}</span>
                                <span class="destination-count">${item.count} bookings</span>
                            </li>`
                        ).join('');
                    } else {
                        destinationsList.innerHTML = '<p>No destination data available for this period.</p>';
                    }
                }

            } catch (error) {
                console.error("Error fetching summary data:", error);
                showNotification("Failed to load summary data.", 'error');
            }
        }

        async function fetchDashboardData() {
    try {
        console.log("üîÑ Fetching dashboard data...");
        const dashboardResponse = await fetch('/admin-dashboard/data', {
            credentials: 'include'
        });

        if (dashboardResponse.status === 401) {
            handleAdminLogout();
            return;
        }

        if (!dashboardResponse.ok) {
            throw new Error(`HTTP error! Status: ${dashboardResponse.status}`);
        }

        const dashboardData = await dashboardResponse.json();
        
        // Fetch destinations data
        const destinationsResponse = await fetch('/api/analytics/popular-destinations', {
            credentials: 'include'
        });
        
        if (!destinationsResponse.ok) {
            throw new Error(`HTTP error! Status: ${destinationsResponse.status}`);
        }
        
        const destinationsData = await destinationsResponse.json();
        
        // Combine all data
        const combinedData = {
            ...dashboardData,
            popularDestinations: destinationsData.popularDestinations
        };
        
        console.log("üìå Fetched Data:", combinedData);
        
        // Update summary stats
        updateSummaryStats(combinedData);
        
        // Update UI components
        updateDashboardUI(combinedData);
        updateLastUpdated();
        
    } catch (error) {
        console.error("‚ùå Error fetching dashboard data:", error);
        showNotification("Failed to load dashboard data. Please try again.", 'error');
    }
}

        function updateRecentUsers(users) {
    const usersList = document.getElementById('recent-users-list');
    if (users && users.length > 0) {
        usersList.innerHTML = users.map(user => {
            const date = new Date(user.createdAt);
            const formattedDate = date.toLocaleDateString();
            const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `<li>
                <div><strong>${user.username || user.email}</strong></div>
                <div>Registered on <span class="list-date">${formattedDate}</span> at <span class="list-time">${formattedTime}</span></div>
            </li>`;
        }).join('');
    } else {
        usersList.innerHTML = '<p>No recent user registrations</p>';
    }
}

function updateRecentBookings(bookings) {
    const bookingsList = document.getElementById('recent-bookings-list');
    if (bookings && bookings.length > 0) {
        bookingsList.innerHTML = bookings.map(booking => {
            const date = new Date(booking.createdAt);
            const formattedDate = date.toLocaleDateString();
            const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `<li>
                <div><strong>${booking.fullName || 'Unknown'}</strong> - ${booking.destination || booking.tourDetails?.destination || 'Unknown destination'}</div>
                <div>Booked on <span class="list-date">${formattedDate}</span> at <span class="list-time">${formattedTime}</span></div>
            </li>`;
        }).join('');
    } else {
        bookingsList.innerHTML = '<p>No recent bookings</p>';
    }
}
        function updateSummaryStats(data) {
    // Calculate total users
    const totalUsers = data.usersThisWeek.reduce((sum, item) => sum + item.count, 0);
    document.getElementById('totalUsers').textContent = totalUsers;
    
    // Calculate total bookings
    const totalBookings = data.bookingsThisWeek.reduce((sum, item) => sum + item.count, 0);
    document.getElementById('totalBookings').textContent = totalBookings;
    
    // Calculate total revenue
    const totalRevenue = data.popularDestinations ? 
        data.popularDestinations.reduce((sum, item) => sum + (item.revenue || 0), 0) : 0;
    document.getElementById('totalRevenue').textContent = '‚Ç±' + totalRevenue.toLocaleString();
    
}
function updateDashboardUI(data) {
    // Update user list
    const userList = document.getElementById('user-list');
    if (data.usersThisWeek && data.usersThisWeek.length > 0) {
        userList.innerHTML = data.usersThisWeek.map(item => {
            const date = new Date(item.date);
            const formattedDate = date.toLocaleDateString();
            const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `<li>
                <span class="list-date">${formattedDate}</span>
                <span class="list-time">${formattedTime}</span>: 
                <span class="list-count">${item.count}</span> new users
            </li>`;
        }).join('');
    } else {
        userList.innerHTML = '<p>No user data available for this week</p>';
    }

    // Update booking list
    const bookingList = document.getElementById('booking-list');
    if (data.bookingsThisWeek && data.bookingsThisWeek.length > 0) {
        bookingList.innerHTML = data.bookingsThisWeek.map(item => {
            const date = new Date(item.date);
            const formattedDate = date.toLocaleDateString();
            const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            return `<li>
                <span class="list-date">${formattedDate}</span>
                <span class="list-time">${formattedTime}</span>: 
                <span class="list-count">${item.count}</span> new bookings
            </li>`;
        }).join('');
    } else {
        bookingList.innerHTML = '<p>No booking data available for this week</p>';
    }
    
    // Update destinations list (unchanged)
    const destinationsList = document.getElementById('destinations-list');
    if (data.popularDestinations && data.popularDestinations.length > 0) {
        destinationsList.innerHTML = data.popularDestinations.slice(0, 5).map(item => 
            `<li>
                <span class="destination-name">${item._id || 'Unknown'}</span>
                <span class="destination-count">${item.count} bookings</span>
            </li>`
        ).join('');
    } else {
        destinationsList.innerHTML = '<p>No destination data available</p>';
    }
}


        function updateCharts(data) {
            const userCtx = document.getElementById('usersChart').getContext('2d');
            const bookingCtx = document.getElementById('bookingsChart').getContext('2d');
            const userTrendsCtx = document.getElementById('userTrendsChart').getContext('2d');
            
            // Prepare data for charts
            const labels = data.usersThisWeek.map(item => 
                new Date(item.date).toLocaleDateString('en-US', { weekday: 'short' })
            );
            
            const userData = data.usersThisWeek.map(item => item.count);
            const bookingData = data.bookingsThisWeek.map(item => item.count);
            
            // Create cumulative user data for trends
            const cumulativeUserData = userData.reduce((acc, val, i) => {
                if (i === 0) return [val];
                return [...acc, acc[i-1] + val];
            }, []);
            
            // Destroy existing charts if they exist
            if (userChart) userChart.destroy();
            if (bookingChart) bookingChart.destroy();
            if (userTrendsChart) userTrendsChart.destroy();
            
            // Create new charts
            userChart = new Chart(userCtx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'New Users',
                        data: userData,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        }
                    }
                }
            });
            
            bookingChart = new Chart(bookingCtx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'New Bookings',
                        data: bookingData,
                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        }
                    }
                }
            });
            
            // Create user trends chart (cumulative growth)
            userTrendsChart = new Chart(userTrendsCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Cumulative User Growth',
                        data: cumulativeUserData,
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        }
                    }
                }
            });
        }

        function updateSeasonalTrendsChart(seasonalTrends) {
            if (!seasonalTrends || seasonalTrends.length === 0) {
                console.log("No seasonal trends data available");
                return;
            }

            const ctx = document.getElementById('seasonalTrendsChart').getContext('2d');
            
            // Process data for chart
            // Group by season and sum counts
            const seasonData = {};
            seasonalTrends.forEach(item => {
                const season = item._id.season;
                const destination = item._id.destination || 'Unknown';
                
                if (!seasonData[season]) {
                    seasonData[season] = {};
                }
                
                if (!seasonData[season][destination]) {
                    seasonData[season][destination] = 0;
                }
                
                seasonData[season][destination] += item.count;
            });
            
            // Get unique destinations and seasons
            const destinations = [...new Set(seasonalTrends.map(item => item._id.destination || 'Unknown'))];
            const seasons = ['Winter', 'Spring', 'Summer', 'Fall']; // Fixed order
            
            // Prepare datasets
            const datasets = destinations.map((destination, index) => {
                const color = `hsl(${index * 360 / destinations.length}, 70%, 60%)`;
                
                return {
                    label: destination,
                    data: seasons.map(season => {
                        return seasonData[season] && seasonData[season][destination] ? seasonData[season][destination] : 0;
                    }),
                    backgroundColor: `hsla(${index * 360 / destinations.length}, 70%, 60%, 0.6)`,
                    borderColor: `hsl(${index * 360 / destinations.length}, 70%, 60%)`,
                    borderWidth: 1
                };
            });
            
            // Destroy existing chart if it exists
            if (seasonalTrendsChart) seasonalTrendsChart.destroy();
            
            // Create new chart
            seasonalTrendsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: seasons,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Seasonal Booking Trends by Destination',
                            font: {
                                size: 16
                            }
                        }
                    }
                }
            });
        }

        function updatePaymentMethodsChart(paymentData) {
            if (!paymentData || paymentData.length === 0) {
                console.log("No payment methods data available");
                return;
            }

            const ctx = document.getElementById('paymentMethodsChart').getContext('2d');
            
            // Process data for chart
            // Group by payment method and destination
            const paymentMethodsData = {};
            const destinations = new Set();
            const paymentMethods = new Set();
            
            paymentData.forEach(item => {
                const destination = item._id.destination || 'Unknown';
                const paymentMethod = item._id.paymentMethod || 'Unknown';
                
                destinations.add(destination);
                paymentMethods.add(paymentMethod);
                
                if (!paymentMethodsData[paymentMethod]) {
                    paymentMethodsData[paymentMethod] = {};
                }
                
                paymentMethodsData[paymentMethod][destination] = item.count;
            });
            
            // Convert sets to arrays
            const destinationsArray = [...destinations];
            const paymentMethodsArray = [...paymentMethods];
            
            // Prepare datasets
            const datasets = paymentMethodsArray.map((method, index) => {
                const color = `hsl(${index * 360 / paymentMethodsArray.length}, 70%, 60%)`;
                
                return {
                    label: method.charAt(0).toUpperCase() + method.slice(1),
                    data: destinationsArray.map(destination => {
                        return paymentMethodsData[method] && paymentMethodsData[method][destination] ? 
                            paymentMethodsData[method][destination] : 0;
                    }),
                    backgroundColor: `hsla(${index * 360 / paymentMethodsArray.length}, 70%, 60%, 0.6)`,
                    borderColor: `hsl(${index * 360 / paymentMethodsArray.length}, 70%, 60%)`,
                    borderWidth: 1
                };
            });
            
            // Destroy existing chart if it exists
            if (paymentMethodsChart) paymentMethodsChart.destroy();
            
            // Create new chart
            paymentMethodsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: destinationsArray,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Payment Methods by Destination',
                            font: {
                                size: 16
                            }
                        }
                    }
                }
            });
        }

        function updateDestinationsChart(destinations) {
            if (!destinations || destinations.length === 0) {
                console.log("No destinations data available");
                return;
            }

            const ctx = document.getElementById('destinationsChart').getContext('2d');
            
            // Sort destinations by count in descending order
            const sortedDestinations = [...destinations].sort((a, b) => b.count - a.count);
            
            // Take top 10 destinations
            const topDestinations = sortedDestinations.slice(0, 10);
            
            // Prepare data for chart
            const labels = topDestinations.map(item => item._id || 'Unknown');
            const data = topDestinations.map(item => item.count);
            
            // Generate colors
            const backgroundColors = topDestinations.map((_, index) => 
                `hsla(${index * 360 / topDestinations.length}, 70%, 60%, 0.6)`);
            const borderColors = topDestinations.map((_, index) => 
                `hsl(${index * 360 / topDestinations.length}, 70%, 60%)`);
            
            // Destroy existing chart if it exists
            if (destinationChart) destinationChart.destroy();
            
            // Create new chart
            destinationChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Bookings',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                precision: 0
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Most Popular Destinations',
                            font: {
                                size: 16
                            }
                        }
                    }
                }
            });
        }

        function updateRevenueChart(destinations) {
            if (!destinations || destinations.length === 0) {
                console.log("No destinations data available for Sales chart");
                return;
            }

            const ctx = document.getElementById('revenueChart').getContext('2d');
            
            // Sort destinations by revenue in descending order
            const sortedDestinations = [...destinations].sort((a, b) => (b.revenue || 0) - (a.revenue || 0));
            
            // Take top 10 destinations
            const topDestinations = sortedDestinations.slice(0, 10);
            
            // Prepare data for chart
            const labels = topDestinations.map(item => item._id || 'Unknown');
            const data = topDestinations.map(item => item.revenue || 0);
            
            // Generate colors
            const backgroundColors = topDestinations.map((_, index) => 
                `hsla(${index * 360 / topDestinations.length}, 70%, 60%, 0.6)`);
            const borderColors = topDestinations.map((_, index) => 
                `hsl(${index * 360 / topDestinations.length}, 70%, 60%)`);
            
            // Destroy existing chart if it exists
            if (revenueChart) revenueChart.destroy();
            
            // Create new chart
            revenueChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Sales (‚Ç±)',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '‚Ç±' + value.toLocaleString();
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Sales by Destination',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return '‚Ç±' + context.raw.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateLastUpdated() {
            const now = new Date();
            document.getElementById('lastUpdated').textContent = now.toLocaleString();
        }

        function showNotification(message, type) {
            // Remove any existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => {
                notification.remove();
            });
            
            // Create new notification
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function handleAdminLogout() {
            fetch('/api/admin/logout', {
                method: 'GET',
                credentials: 'include'
            })
            .then(() => {
                localStorage.removeItem('isAdminLoggedIn');
                localStorage.removeItem('adminToken');
                localStorage.removeItem('adminRole');
                localStorage.removeItem('adminName');
                window.location.href = '/';
            })
            .catch(error => {
                console.error('Logout error:', error);
                showNotification('Logout failed. Please try again.', 'error');
            });
        }
        // Mobile menu toggle functionality
const menuToggle = document.getElementById('menuToggle');
const sidebar = document.getElementById('sidebar');
const sidebarOverlay = document.getElementById('sidebarOverlay');

menuToggle.addEventListener('click', function() {
    this.classList.toggle('active');
    sidebar.classList.toggle('active');
    sidebarOverlay.classList.toggle('active');
    
    // Prevent scrolling when sidebar is open
    document.body.style.overflow = sidebar.classList.contains('active') ? 'hidden' : '';
});

sidebarOverlay.addEventListener('click', function() {
    menuToggle.classList.remove('active');
    sidebar.classList.remove('active');
    this.classList.remove('active');
    document.body.style.overflow = '';
});

// Close sidebar when clicking on a link (for mobile)
const sidebarLinks = document.querySelectorAll('.sidebar-nav a');
sidebarLinks.forEach(link => {
    link.addEventListener('click', function() {
        if (window.innerWidth <= 768) {
            menuToggle.classList.remove('active');
            sidebar.classList.remove('active');
            sidebarOverlay.classList.remove('active');
            document.body.style.overflow = '';
        }
    });
});

// Enhanced notification function with success type
function showNotification(message, type) {
    // Remove any existing notifications
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => {
        notification.remove();
    });
    
    // Create new notification
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Remove notification after 3 seconds
    setTimeout(() => {
        notification.remove();
    }, 3000);
}
let timeBasedUsersChart = null;
let timeBasedBookingsChart = null;
let timeBasedRevenueChart = null;
let currentPeriod = 'weekly';

document.addEventListener('DOMContentLoaded', function() {
  // ‚úÖ Populate Weekly Year dropdown
  const weeklyYearSelect = document.getElementById('weekly-year');
  const currentYear = new Date().getFullYear();
  for (let y = currentYear - 5; y <= currentYear + 1; y++) {
    const opt = document.createElement('option');
    opt.value = y;
    opt.textContent = y;
    if (y === currentYear) opt.selected = true;
    weeklyYearSelect.appendChild(opt);
  }

  // ‚úÖ Populate Monthly Year dropdown
  const monthYearSelect = document.getElementById('monthly-year');
  for (let y = currentYear; y >= currentYear - 5; y--) {
    const option = document.createElement('option');
    option.value = y;
    option.textContent = y;
    monthYearSelect.appendChild(option);
  }

  // ‚úÖ Tab switching
  const chartTabs = document.querySelectorAll('.chart-tabs .chart-tab');
  chartTabs.forEach(tab => {
    tab.addEventListener('click', function() {
      chartTabs.forEach(t => t.classList.remove('active'));
      this.classList.add('active');
      document.querySelectorAll('.chart-tab-content').forEach(c => c.classList.remove('active'));

      const period = this.getAttribute('data-period');
      currentPeriod = period;

      if (period === 'weekly') {
        document.querySelector('.weekly-selector').classList.add('active');
        fetchWeeklyAnalytics();
      } else if (period === 'monthly') {
        document.querySelector('.monthly-selector').classList.add('active');
        fetchMonthlyAnalytics();
      } else if (period === 'yearly') {
        document.querySelector('.yearly-selector').classList.add('active');
        fetchYearlyAnalytics();
      }
    });
  });

  // ‚úÖ Apply button event listeners
  document.getElementById('weekly-apply-range').addEventListener('click', fetchWeeklyAnalytics);
  document.getElementById('monthly-apply').addEventListener('click', fetchMonthlyAnalytics);
  document.getElementById('yearly-apply').addEventListener('click', fetchYearlyAnalytics);

  // ‚úÖ Initial fetch
  fetchWeeklyAnalytics();
});

// ‚úÖ Weekly Analytics
async function fetchWeeklyAnalytics() {
  try {
    const month = parseInt(document.getElementById('weekly-month').value);
    const year = parseInt(document.getElementById('weekly-year').value);

    const startDate = new Date(year, month, 1);
    const endDate = new Date(year, month + 1, 0);

    const response = await fetch(`/api/analytics/weekly?startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`, {
      credentials: 'include'
    });

    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

    const result = await response.json();
    if (result.success) {
      updateTimeBasedCharts('weekly', result.data);
    }
  } catch (error) {
    console.error('Error fetching weekly analytics:', error);
    showNotification('Failed to load weekly analytics data', 'error');
  }
}

// ‚úÖ Monthly Analytics
async function fetchMonthlyAnalytics() {
  try {
    const year = document.getElementById('monthly-year').value;
    const response = await fetch(`/api/analytics/monthly?year=${year}`, { credentials: 'include' });
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

    const data = await response.json();
    updateTimeBasedCharts('monthly', data);
  } catch (error) {
    console.error('Error fetching monthly analytics:', error);
    showNotification('Failed to load monthly analytics data', 'error');
  }
}

// ‚úÖ Yearly Analytics
async function fetchYearlyAnalytics() {
  try {
    const response = await fetch('/api/analytics/yearly', { credentials: 'include' });
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

    const data = await response.json();
    updateTimeBasedCharts('yearly', data);
  } catch (error) {
    console.error('Error fetching yearly analytics:', error);
    showNotification('Failed to load yearly analytics data', 'error');
  }
}

// ‚úÖ Chart Data Processor
function updateTimeBasedCharts(period, data) {
  let labels = [], userData = [], bookingData = [], revenueData = [];

  if (period === 'weekly') {
    const weekEntries = Object.entries(data);
    weekEntries.forEach(([weekStart, values]) => {
      const start = new Date(weekStart);
      const end = new Date(start);
      end.setDate(start.getDate() + 6);
      labels.push(`${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`);
      userData.push(values.users || 0);
      bookingData.push(values.bookings || 0);
      revenueData.push(values.revenue || 0);
    });
  } else if (period === 'monthly') {
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    const year = document.getElementById('monthly-year').value;
    const monthlyData = Array(12).fill().map(() => ({ users: 0, bookings: 0, revenue: 0 }));
    data.monthlyUsers.forEach(item => {
      if (item._id.year.toString() === year) monthlyData[item._id.month - 1].users = item.count;
    });
    data.monthlyBookings.forEach(item => {
      if (item._id.year.toString() === year) {
        monthlyData[item._id.month - 1].bookings = item.count;
        monthlyData[item._id.month - 1].revenue = item.revenue;
      }
    });
    labels = monthNames;
    userData = monthlyData.map(m => m.users);
    bookingData = monthlyData.map(m => m.bookings);
    revenueData = monthlyData.map(m => m.revenue);
  } else if (period === 'yearly') {
    const years = new Set();
    data.yearlyUsers.forEach(item => years.add(item._id.year));
    data.yearlyBookings.forEach(item => years.add(item._id.year));
    const sortedYears = Array.from(years).sort();
    labels = sortedYears.map(y => y.toString());
    userData = sortedYears.map(y => (data.yearlyUsers.find(i => i._id.year === y)?.count) || 0);
    bookingData = sortedYears.map(y => (data.yearlyBookings.find(i => i._id.year === y)?.count) || 0);
    revenueData = sortedYears.map(y => (data.yearlyBookings.find(i => i._id.year === y)?.revenue) || 0);
  }

  updateUsersChart(labels, userData);
  updateBookingsChart(labels, bookingData);
  updateRevenueChart(labels, revenueData);
}

// ‚úÖ Moving Average Helper
function calculateMovingAverage(data, windowSize) {
  const averages = [];
  for (let i = 0; i < data.length; i++) {
    const start = Math.max(0, i - windowSize + 1);
    const slice = data.slice(start, i + 1);
    averages.push(Math.round(slice.reduce((a, b) => a + b, 0) / slice.length));
  }
  return averages;
}

// ‚úÖ Chart Updaters (with Moving Averages)
function updateUsersChart(labels, data) {
  const ctx = document.getElementById('timeBasedUsersChart').getContext('2d');
  if (timeBasedUsersChart) timeBasedUsersChart.destroy();
  const avg = calculateMovingAverage(data, 2);
  timeBasedUsersChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        { label: 'Users', data, borderColor: 'rgba(54,162,235,1)', fill: true },
        { label: 'Moving Avg', data: avg, borderColor: 'rgba(255,159,64,1)', fill: false }
      ]
    }
  });
}

function updateBookingsChart(labels, data) {
  const ctx = document.getElementById('timeBasedBookingsChart').getContext('2d');
  if (timeBasedBookingsChart) timeBasedBookingsChart.destroy();
  const avg = calculateMovingAverage(data, 2);
  timeBasedBookingsChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        { label: 'Bookings', data, borderColor: 'rgba(255,99,132,1)', fill: true },
        { label: 'Moving Avg', data: avg, borderColor: 'rgba(255,206,86,1)', fill: false }
      ]
    }
  });
}

function updateRevenueChart(labels, data) {
  const ctx = document.getElementById('timeBasedRevenueChart').getContext('2d');
  if (timeBasedRevenueChart) timeBasedRevenueChart.destroy();
  const avg = calculateMovingAverage(data, 2);
  timeBasedRevenueChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        { label: 'Sales (‚Ç±)', data, borderColor: 'rgba(75,192,192,1)', fill: true },
        { label: 'Moving Avg', data: avg, borderColor: 'rgba(153,102,255,1)', fill: false }
      ]
    }
  });
}

let seasonalTrendsChart = null;
let predictedDestinationsChart = null;
document.addEventListener('DOMContentLoaded', function() {
    const seasonalYearSelect = document.getElementById('seasonal-year');
    const currentYear = new Date().getFullYear();
    for (let year = currentYear; year >= currentYear - 5; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        seasonalYearSelect.appendChild(option);
    }

    document.getElementById('seasonal-apply').addEventListener('click', fetchSeasonalAnalytics);
});


function updateSeasonalTrendsChart(seasonalTrends) {
    const ctx = document.getElementById('seasonalTrendsChart').getContext('2d');
    
    // Process data for chart
    const seasonData = {};
    seasonalTrends.forEach(item => {
        const season = item.season;
        const destination = item.destination || 'Unknown';
        
        if (!seasonData[season]) {
            seasonData[season] = {};
        }
        
        if (!seasonData[season][destination]) {
            seasonData[season][destination] = 0;
        }
        
        seasonData[season][destination] += item.count;
    });

    const seasons = ['Winter', 'Spring', 'Summer', 'Fall', 'Wet Season', 'Dry Season'];
    const destinations = [...new Set(seasonalTrends.map(item => item.destination || 'Unknown'))];

    const datasets = destinations.map((destination, index) => {
        const color = `hsl(${index * 360 / destinations.length}, 70%, 60%)`;
        return {
            label: destination,
            data: seasons.map(season => seasonData[season] && seasonData[season][destination] ? seasonData[season][destination] : 0),
            backgroundColor: `hsla(${index * 360 / destinations.length}, 70%, 60%, 0.6)`,
            borderColor: color,
            borderWidth: 1
        };
    });

    if (seasonalTrendsChart) seasonalTrendsChart.destroy();
    
    seasonalTrendsChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: seasons,
            datasets: datasets
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        precision: 0
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Seasonal Booking Trends by Destination',
                    font: {
                        size: 16
                    }
                }
            }
        }
    });
}

function updatePredictedDestinationsChart(predictedDestinations) {
    const ctx = document.getElementById('predictedBookingsChart').getContext('2d');

    // Define colors for each season
    const seasonColors = {
        Winter: 'rgba(54, 162, 235, 0.6)', // Blue
        Spring: 'rgba(75, 192, 192, 0.6)', // Green
        Summer: 'rgba(255, 206, 86, 0.6)', // Yellow
        Fall: 'rgba(255, 159, 64, 0.6)', // Orange
        'Wet Season': 'rgba(54, 162, 235, 0.6)', // Blue
        'Dry Season': 'rgba(75, 192, 192, 0.6)', // Green
        Monsoon: 'rgba(255, 206, 86, 0.6)', // Yellow
        'Post-Monsoon': 'rgba(255, 159, 64, 0.6)' // Orange
    };

    // Prepare data for the chart
    const labels = predictedDestinations[0].destinations.map(dest => dest.destination);
    const datasets = predictedDestinations.map(item => {
        return {
            label: item.season,
            data: item.destinations.map(dest => dest.predictedCount),
            backgroundColor: seasonColors[item.season],
            borderColor: seasonColors[item.season].replace('0.6', '1'),
            borderWidth: 1,
            fill: true
        };
    });

    if (predictedDestinationsChart) predictedDestinationsChart.destroy();

    predictedDestinationsChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: { 
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        precision: 0
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Predicted Popular Destinations for Each Season',
                    font: {
                        size: 16
                    }
                }
            }
        }
    });
}

document.addEventListener('DOMContentLoaded', function() {
    fetchSeasonalAnalytics();
});

    </script>
    <script>
// ===== SEASON ANALYTICS CHART =====
async function loadSeasonAnalytics() {
  try {
    const res = await fetch('/api/analytics/seasons');
    const json = await res.json();
    if (!json.success) return;

    const labels = json.data.map(d => d._id);
    const values = json.data.map(d => d.count);

    const ctx = document.getElementById('seasonChart').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'Bookings',
          data: values,
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: { display: true, text: 'Bookings per Season' },
          legend: { display: false }
        },
        scales: {
          y: { beginAtZero: true }
        }
      }
    });
  } catch (err) {
    console.error("‚ùå Error loading season analytics:", err);
  }
}

// ===== CLIMATE ANALYTICS CHART =====
async function loadClimateAnalytics() {
  try {
    const res = await fetch('/api/analytics/climate');
    const json = await res.json();
    if (!json.success) return;

    const labels = json.data.map(d => d._id);
    const temps = json.data.map(d => d.avgTemperature ? d.avgTemperature.toFixed(1) : 0);
    const rain = json.data.map(d => d.avgRainfall ? d.avgRainfall.toFixed(1) : 0);

    const ctx = document.getElementById('climateChart').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          {
            label: 'Avg Temperature (¬∞C)',
            data: temps,
            borderWidth: 1
          },
          {
            label: 'Avg Rainfall (mm)',
            data: rain,
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          title: { display: true, text: 'Average Climate by Season' }
        },
        scales: {
          y: { beginAtZero: true }
        }
      }
    });
  } catch (err) {
    console.error("‚ùå Error loading climate analytics:", err);
  }
}

// üöÄ Initialize both charts on load
document.addEventListener("DOMContentLoaded", () => {
  loadSeasonAnalytics();
  loadClimateAnalytics();
});
</script>
<!-- SheetJS CDN (client-side Excel creation) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

<script>
  // Hide other export buttons (we keep only Export to Excel visible)
  (function cleanExportButtons() {
    const printBtn = document.getElementById('printDashboard');
    const csvBtn = document.getElementById('exportCSV');
    if (printBtn) printBtn.style.display = 'none';
    if (csvBtn) csvBtn.style.display = 'none';
  })();

  // Main export handler
  document.getElementById('exportExcel').addEventListener('click', exportToExcel);

  async function exportToExcel() {
    try {
      showNotification('Preparing Excel export...', 'success');

      // 1) Gather data in parallel
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-');
      const filename = `Admin_Dashboard_Report_${timestamp}.xlsx`;

      // summary + dashboard endpoints (adapted to endpoints used in your script)
      const [dashboardRes, popularRes, summaryRes] = await Promise.all([
        fetch('/admin-dashboard/data', { credentials: 'include' }),
        fetch('/api/analytics/popular-destinations', { credentials: 'include' }),
        fetch('/api/analytics/summary?period=all', { credentials: 'include' })
      ]);

      if (!dashboardRes.ok) throw new Error('Failed to fetch dashboard data.');
      if (!popularRes.ok) throw new Error('Failed to fetch popular destinations.');
      if (!summaryRes.ok) console.warn('Summary endpoint returned non-ok.');

      const dashboardData = await dashboardRes.json();
      const popularData = await popularRes.json();
      const summaryData = summaryRes.ok ? await summaryRes.json() : null;

      // 2) Time-based analytics (daily/monthly/yearly)
      // For daily: use current 30-day window (or existing UI selection)
      const endDateISO = new Date().toISOString().split('T')[0];
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const startDateISO = thirtyDaysAgo.toISOString().split('T')[0];

      const [dailyRes, monthlyRes, yearlyRes] = await Promise.all([
        fetch(`/api/analytics/daily?startDate=${startDateISO}&endDate=${endDateISO}`, { credentials: 'include' }),
        fetch(`/api/analytics/monthly?year=${(new Date()).getFullYear()}`, { credentials: 'include' }),
        fetch(`/api/analytics/yearly`, { credentials: 'include' })
      ]);

      const dailyData = dailyRes.ok ? await dailyRes.json() : { dailyUsers: [], dailyBookings: [] };
      const monthlyData = monthlyRes.ok ? await monthlyRes.json() : { monthlyUsers: [], monthlyBookings: [] };
      const yearlyData = yearlyRes.ok ? await yearlyRes.json() : { yearlyUsers: [], yearlyBookings: [] };

      // 3) Build worksheets (using arrays of arrays for consistent formatting)
      const wb = XLSX.utils.book_new();

      // Helper: style headers by capitalizing and using first row as header.
      // Summary sheet
      const summaryRows = [
        ['A.BEE Travel and Tours - Admin Dashboard Report'],
        ['Generated on:', (new Date()).toLocaleString()],
        ['Report Filename:', filename],
        [],
        ['Summary'],
      ];

      // Totals from summaryData (safe fallback to dashboard)
      const totalUsers = (summaryData && summaryData.data && summaryData.data.totalUsers) || (dashboardData && dashboardData.totalUsers) || '--';
      const totalBookings = (summaryData && summaryData.data && summaryData.data.totalBookings) || (dashboardData && dashboardData.totalBookings) || '--';
      const totalSales = (summaryData && summaryData.data && summaryData.data.totalSales) || (dashboardData && dashboardData.totalRevenue) || 0;

      summaryRows.push(['Total Registered Users', totalUsers]);
      summaryRows.push(['Total Bookings', totalBookings]);
      summaryRows.push(['Total Sales (‚Ç±)', typeof totalSales === 'number' ? totalSales : String(totalSales)]);
      summaryRows.push([]);
      summaryRows.push(['Report Filters']);
      summaryRows.push(['Users period', document.getElementById('usersPeriod') ? document.getElementById('usersPeriod').value : 'all']);
      summaryRows.push(['Bookings period', document.getElementById('bookingsPeriod') ? document.getElementById('bookingsPeriod').value : 'all']);
      summaryRows.push(['Sales period', document.getElementById('salesPeriod') ? document.getElementById('salesPeriod').value : 'all']);
      summaryRows.push([]);

      const wsSummary = XLSX.utils.aoa_to_sheet(summaryRows);

      // Apply number format to Total Sales cell (simple approach: find the cell and set z)
      // We expect Total Sales to be at row index where value exists; search for 'Total Sales (‚Ç±)'
      for (let R = 0; R <= 40; ++R) {
        const cellAddr = XLSX.utils.encode_cell({ r: R, c: 0 });
        const cell = wsSummary[cellAddr];
        if (cell && typeof cell.v === 'string' && cell.v.includes('Total Sales')) {
          // value is in column B (c=1) at same row
          const valCellAddr = XLSX.utils.encode_cell({ r: R, c: 1 });
          const valCell = wsSummary[valCellAddr];
          if (valCell) {
            valCell.z = '‚Ç±#,##0.00';
            // If value is string, convert to number if possible
            if (typeof valCell.v === 'string') {
              const parsed = Number(valCell.v.toString().replace(/[^0-9.-]+/g,""));
              if (!isNaN(parsed)) {
                valCell.v = parsed;
              }
            }
          }
          break;
        }
      }

      XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

      // Recent Users sheet (from dashboardData.usersThisWeek)
      const usersRows = [
        ['Date', 'Time', 'New Users', 'Description']
      ];
      if (dashboardData && Array.isArray(dashboardData.usersThisWeek) && dashboardData.usersThisWeek.length) {
        dashboardData.usersThisWeek.forEach(item => {
          const dateObj = item.date ? new Date(item.date) : null;
          usersRows.push([
            dateObj ? dateObj.toLocaleDateString() : '',
            dateObj ? dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '',
            item.count || 0,
            item.note || ''
          ]);
        });
      } else {
        usersRows.push(['No data', '', '', '']);
      }
      const wsUsers = XLSX.utils.aoa_to_sheet(usersRows);
      XLSX.utils.book_append_sheet(wb, wsUsers, 'Recent Users');

      // Recent Bookings sheet
      const bookingsRows = [
        ['Date', 'Time', 'New Bookings', 'Description']
      ];
      if (dashboardData && Array.isArray(dashboardData.bookingsThisWeek) && dashboardData.bookingsThisWeek.length) {
        dashboardData.bookingsThisWeek.forEach(item => {
          const dateObj = item.date ? new Date(item.date) : null;
          bookingsRows.push([
            dateObj ? dateObj.toLocaleDateString() : '',
            dateObj ? dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '',
            item.count || 0,
            item.note || ''
          ]);
        });
      } else {
        bookingsRows.push(['No data', '', '', '']);
      }
      const wsBookings = XLSX.utils.aoa_to_sheet(bookingsRows);
      XLSX.utils.book_append_sheet(wb, wsBookings, 'Recent Bookings');

      // Top Destinations sheet
      const destRows = [
        ['Destination', 'Bookings Count', 'Revenue (‚Ç±)']
      ];
      const destArray = (popularData && popularData.popularDestinations) || (popularData && popularData.data) || [];
      if (Array.isArray(destArray) && destArray.length) {
        destArray.forEach(d => {
          destRows.push([
            d._id || d.destination || 'Unknown',
            d.count || 0,
            d.revenue || 0
          ]);
        });
      } else {
        // fallback to dashboardData.popularDestinations
        const fallback = dashboardData && dashboardData.popularDestinations;
        if (Array.isArray(fallback) && fallback.length) {
          fallback.forEach(d => destRows.push([d._id || d.destination || 'Unknown', d.count || 0, d.revenue || 0]));
        } else {
          destRows.push(['No data', '', '']);
        }
      }
      const wsDest = XLSX.utils.aoa_to_sheet(destRows);
      // format revenue column (column C -> c=2)
      const rangeDest = XLSX.utils.decode_range(wsDest['!ref']);
      for (let R = rangeDest.s.r + 1; R <= rangeDest.e.r; ++R) {
        const cell = wsDest[XLSX.utils.encode_cell({ r: R, c: 2 })];
        if (cell) cell.z = '‚Ç±#,##0.00';
      }
      XLSX.utils.book_append_sheet(wb, wsDest, 'Top Destinations');

      // Daily Analytics sheet
      const dailyRows = [['Date', 'Users', 'Bookings', 'Revenue (‚Ç±)']];
      if (dailyData && Array.isArray(dailyData.dailyUsers)) {
        // Build a map date -> users/bookings/revenue to ensure all dates present
        const dateMap = new Map();
        // init from dailyUsers keys
        dailyData.dailyUsers.forEach(u => dateMap.set(u._id, { users: u.count, bookings: 0, revenue: 0 }));
        (dailyData.dailyBookings || []).forEach(b => {
          if (!dateMap.has(b._id)) dateMap.set(b._id, { users: 0, bookings: 0, revenue: 0 });
          const cur = dateMap.get(b._id);
          cur.bookings = b.count || 0;
          cur.revenue = b.revenue || 0;
          dateMap.set(b._id, cur);
        });
        // Convert map to sorted keys
        Array.from(dateMap.keys()).sort().forEach(dateKey => {
          const cur = dateMap.get(dateKey);
          dailyRows.push([
            dateKey,
            cur.users || 0,
            cur.bookings || 0,
            cur.revenue || 0
          ]);
        });
      } else {
        dailyRows.push(['No data', 0, 0, 0]);
      }
      const wsDaily = XLSX.utils.aoa_to_sheet(dailyRows);
      // format revenue column
      const rangeDaily = XLSX.utils.decode_range(wsDaily['!ref']);
      for (let R = rangeDaily.s.r + 1; R <= rangeDaily.e.r; ++R) {
        const cell = wsDaily[XLSX.utils.encode_cell({ r: R, c: 3 })];
        if (cell) cell.z = '‚Ç±#,##0.00';
      }
      XLSX.utils.book_append_sheet(wb, wsDaily, 'Daily Analytics');

      // Monthly Analytics sheet
      const monthlyRows = [['Month', 'Users', 'Bookings', 'Revenue (‚Ç±)']];
      if (monthlyData && Array.isArray(monthlyData.monthlyUsers)) {
        // Build month index 1..12
        const months = Array.from({ length: 12 }, (_, i) => ({ month: i + 1, users: 0, bookings: 0, revenue: 0 }));
        monthlyData.monthlyUsers.forEach(u => {
          const idx = u._id && u._id.month ? u._id.month - 1 : null;
          if (idx !== null && months[idx]) months[idx].users = u.count || 0;
        });
        (monthlyData.monthlyBookings || []).forEach(b => {
          const idx = b._id && b._id.month ? b._id.month - 1 : null;
          if (idx !== null && months[idx]) {
            months[idx].bookings = b.count || 0;
            months[idx].revenue = b.revenue || 0;
          }
        });
        const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        months.forEach(m => monthlyRows.push([monthNames[m.month - 1], m.users, m.bookings, m.revenue]));
      } else {
        monthlyRows.push(['No data', 0, 0, 0]);
      }
      const wsMonthly = XLSX.utils.aoa_to_sheet(monthlyRows);
      const rangeMon = XLSX.utils.decode_range(wsMonthly['!ref']);
      for (let R = rangeMon.s.r + 1; R <= rangeMon.e.r; ++R) {
        const cell = wsMonthly[XLSX.utils.encode_cell({ r: R, c: 3 })];
        if (cell) cell.z = '‚Ç±#,##0.00';
      }
      XLSX.utils.book_append_sheet(wb, wsMonthly, 'Monthly Analytics');

      // Yearly Analytics sheet
      const yearlyRows = [['Year', 'Users', 'Bookings', 'Revenue (‚Ç±)']];
      if (yearlyData && Array.isArray(yearlyData.yearlyUsers)) {
        // Build map year -> values
        const yearsMap = {};
        (yearlyData.yearlyUsers || []).forEach(u => {
          const y = u._id && u._id.year ? u._id.year : 'Unknown';
          yearsMap[y] = yearsMap[y] || { users: 0, bookings: 0, revenue: 0 };
          yearsMap[y].users = u.count || 0;
        });
        (yearlyData.yearlyBookings || []).forEach(b => {
          const y = b._id && b._id.year ? b._id.year : 'Unknown';
          yearsMap[y] = yearsMap[y] || { users: 0, bookings: 0, revenue: 0 };
          yearsMap[y].bookings = b.count || 0;
          yearsMap[y].revenue = b.revenue || 0;
        });
        const yearKeys = Object.keys(yearsMap).sort();
        if (yearKeys.length) {
          yearKeys.forEach(y => yearlyRows.push([y, yearsMap[y].users, yearsMap[y].bookings, yearsMap[y].revenue]));
        } else {
          yearlyRows.push(['No data', 0, 0, 0]);
        }
      } else {
        yearlyRows.push(['No data', 0, 0, 0]);
      }
      const wsYearly = XLSX.utils.aoa_to_sheet(yearlyRows);
      const rangeYear = XLSX.utils.decode_range(wsYearly['!ref']);
      for (let R = rangeYear.s.r + 1; R <= rangeYear.e.r; ++R) {
        const cell = wsYearly[XLSX.utils.encode_cell({ r: R, c: 3 })];
        if (cell) cell.z = '‚Ç±#,##0.00';
      }
      XLSX.utils.book_append_sheet(wb, wsYearly, 'Yearly Analytics');

      // 4) Finalize & download
      XLSX.writeFile(wb, filename);

      showNotification('Excel exported ‚Äî check your downloads folder.', 'success');
    } catch (err) {
      console.error('Export error:', err);
      showNotification('Failed to export Excel. See console for details.', 'error');
    }
  } // end exportToExcel

  /* Reuse your showNotification function if defined, otherwise define a fallback */
  if (typeof showNotification !== 'function') {
    function showNotification(message, type) {
      const existing = document.querySelectorAll('.notification');
      existing.forEach(e => e.remove());
      const n = document.createElement('div');
      n.className = `notification ${type === 'error' ? 'error' : 'success'}`;
      n.textContent = message;
      document.body.appendChild(n);
      setTimeout(() => n.remove(), 3500);
    }
  }
</script>
<script>
async function drawLineChart(endpoint, chartId, label, color) {
  try {
    const res = await fetch(endpoint);
    const data = await res.json();

    if (!data.success || !data.forecast) {
      console.warn(`‚ö†Ô∏è ${label} forecast failed:`, data.message);
      const el = document.getElementById(chartId);
      if (el) el.outerHTML = `<p style="color:red;">‚ö†Ô∏è ${label}: ${data.message}</p>`;
      return;
    }

    const labels = data.forecast.map(f => new Date(f.ds).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
    const values = data.forecast.map(f => f.yhat);

    new Chart(document.getElementById(chartId), {
      type: "line",
      data: {
        labels,
        datasets: [{
          label,
          data: values,
          borderColor: color,
          backgroundColor: color + "20",
          fill: true,
          tension: 0.3,
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          title: { display: true, text: label }
        },
        scales: {
          y: { beginAtZero: true }
        }
      }
    });
  } catch (err) {
    console.error(`‚ùå ${label} Forecast Error:`, err);
  }
}

async function drawBarChart(endpoint, chartId, label, color) {
  try {
    const res = await fetch(endpoint);
    const data = await res.json();

    if (!data.success || !data.forecast) {
      document.getElementById(chartId).outerHTML = `<p style="color:red;">‚ö†Ô∏è ${label}: No data</p>`;
      return;
    }

    const labels = data.forecast.map(f => f.destination || f.ds);
    const values = data.forecast.map(f => f.totalBookings || f.predictedBookings || f.yhat);

    new Chart(document.getElementById(chartId), {
      type: "bar",
      data: {
        labels,
        datasets: [{
          label,
          data: values,
          backgroundColor: color + "90",
          borderColor: color,
          borderWidth: 1,
          borderRadius: 6
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          title: { display: true, text: label }
        },
        scales: {
          x: { title: { display: true, text: "Category" } },
          y: { title: { display: true, text: "Value" }, beginAtZero: true }
        }
      }
    });
  } catch (err) {
    console.error(`‚ùå ${label} Forecast Error:`, err);
  }
}

document.addEventListener("DOMContentLoaded", () => {
  // üîÆ Main Time-Series Forecasts
  drawLineChart("/api/predict/sales", "salesForecastChart", "Sales Forecast (‚Ç±)", "#2196F3");
  drawLineChart("/api/predict/users", "userForecastChart", "User Sign-ups Forecast", "#FF9800");
  drawLineChart("/api/predict/bookings", "bookingForecastChart", "Booking Forecast", "#4CAF50");

  // üïí Seasonal Trends
  drawBarChart("/api/predict/seasonal", "seasonalBookingChart", "Seasonal Booking Forecast", "#F26523");

  // üåç Destination Demand
  drawBarChart("/api/predict/destination-demand", "destinationDemandChart", "Top Trending Destinations", "#6F42C1");
});
</script>
<script>
async function loadRevenueForecast() {
  const note = document.getElementById("revenueForecastNote");
  const ctx = document.getElementById("revenueForecastChart").getContext("2d");

  try {
    const res = await fetch("/api/predict/revenue-by-country");
    const data = await res.json();

    if (!data.success || !data.forecast || data.forecast.length === 0) {
      note.textContent = "No revenue forecast data available.";
      return;
    }

    const countries = data.forecast.map(f => f.country);
    const revenues = data.forecast.map(f => f.predictedRevenue.toFixed(2));

    new Chart(ctx, {
      type: "bar",
      data: {
        labels: countries,
        datasets: [{
          label: "Predicted Revenue (‚Ç±)",
          data: revenues,
          backgroundColor: "rgba(255, 206, 86, 0.6)",
          borderColor: "rgba(255, 206, 86, 1)",
          borderWidth: 1,
          borderRadius: 6
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          title: {
            display: true,
            text: "Predicted Top 10 Countries by Revenue (Next Month)",
            font: { size: 16 }
          }
        },
        scales: {
          x: { title: { display: true, text: "Country" } },
          y: { title: { display: true, text: "Predicted Revenue (‚Ç±)" }, beginAtZero: true }
        }
      }
    });

    note.textContent = "‚úÖ Revenue forecast generated successfully.";
  } catch (err) {
    console.error("‚ùå Revenue Forecast Error:", err);
    note.textContent = "Error loading revenue forecast.";
  }
}

document.addEventListener("DOMContentLoaded", loadRevenueForecast);
</script>

<script>
async function loadRevenueForecastByCountry() {
  const note = document.getElementById("revenueByCountryNote");
  const ctx = document.getElementById("revenueByCountryChart")?.getContext("2d");
  if (!ctx) return console.warn("‚ö†Ô∏è Missing canvas: #revenueByCountryChart");

  try {
    const res = await fetch("/api/predict/revenue-by-country");
    const data = await res.json();

    if (!data.success || !data.forecast || data.forecast.length === 0) {
      note.textContent = "No revenue forecast data available.";
      return;
    }

    const countries = data.forecast.map(f => f.country);
    const revenues = data.forecast.map(f => Math.max(0, f.predictedRevenue.toFixed(0))); // prevent negatives

    new Chart(ctx, {
      type: "bar",
      data: {
        labels: countries,
        datasets: [{
          label: "Predicted Revenue (‚Ç±)",
          data: revenues,
          backgroundColor: "rgba(75, 192, 192, 0.6)",
          borderColor: "rgba(75, 192, 192, 1)",
          borderWidth: 1,
          borderRadius: 6,
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: "Revenue Forecast by Country (‚Ç±)",
            font: { size: 16 }
          },
          legend: { display: false },
        },
        scales: {
          x: { title: { display: true, text: "Country" } },
          y: { beginAtZero: true, title: { display: true, text: "Predicted Revenue (‚Ç±)" } },
        },
      }
    });

    note.textContent = "‚úÖ Revenue forecast loaded successfully!";
  } catch (err) {
    console.error("‚ùå Revenue Forecast Error:", err);
    note.textContent = "Error loading forecast.";
  }
}

// Auto-load on page load
document.addEventListener("DOMContentLoaded", loadRevenueForecastByCountry);
</script>

  <script>
  // üß† Helper for updating forecast metrics
  function updateForecastMetrics(type, mape, rmse) {
    const elem = document.getElementById(`${type}ForecastAccuracy`);
    if (!elem) return;
    let color = "gray";
    if (mape <= 5) color = "green";
    else if (mape <= 15) color = "orange";
    else color = "red";
    elem.style.color = color;
    elem.innerHTML = `MAPE: ${mape?.toFixed(2) ?? "--"}% | RMSE: ${rmse?.toFixed(2) ?? "--"}`;
  }

  // ü™Ñ Generic forecast loader
  async function loadForecast(endpoint, chartId, label, type) {
    try {
      const res = await fetch(endpoint);
      const data = await res.json();

      if (!data.success) throw new Error(data.message || "No forecast data");

      const ctx = document.getElementById(chartId).getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.forecast.map(f => new Date(f.ds).toLocaleDateString()),
          datasets: [{
            label: `${label} (Predicted)`,
            data: data.forecast.map(f => f.yhat),
            borderColor: '#4f46e5',
            backgroundColor: 'rgba(79,70,229,0.1)',
            tension: 0.3,
            fill: true
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            title: { display: true, text: label }
          }
        }
      });

      if (type) updateForecastMetrics(type, data.mape, data.rmse);
    } catch (err) {
      console.error(`‚ùå ${label} Forecast Error:`, err);
      const note = document.getElementById(`${type}ForecastAccuracy`);
      if (note) note.textContent = "Error loading forecast";
    }
  }

  // üìà Load all on page load
  document.addEventListener('DOMContentLoaded', async () => {
   await loadForecast('sales', 'salesForecastChart', 'salesAccuracy', 'salesNote');
await loadForecast('users', 'userForecastChart', 'userAccuracy', 'userNote');
await loadForecast('bookings', 'bookingForecastChart', 'bookingAccuracy', 'bookingNote');
await loadForecast('seasonal', 'seasonalBookingChart', 'seasonalAccuracy', 'seasonalNote');
  });
  </script>
 <script>
// üéØ Generic Forecast Chart Loader (with confidence interval)
async function loadForecast(type, chartId, accuracyId, noteId, horizon = 180) {
  try {
    const response = await fetch(`/api/predict/${type}?horizon=${horizon}`);
    const data = await response.json();

    if (!data.success || !data.forecast?.length) {
      document.getElementById(noteId).textContent = "‚ö†Ô∏è No forecast data available.";
      return;
    }

    // üßÆ Display accuracy metrics
    document.getElementById(accuracyId).textContent =
      `MAPE: ${data.mape?.toFixed(2) ?? "--"}% | RMSE: ${data.rmse?.toFixed(2) ?? "--"}`;
    document.getElementById(noteId).textContent = data.note || "Forecast loaded successfully.";

    // ü™Ñ Chart setup
    const ctx = document.getElementById(chartId).getContext("2d");
    if (window[chartId]) window[chartId].destroy(); // Reset old chart

    window[chartId] = new Chart(ctx, {
      type: "line",
      data: {
        labels: data.forecast.map(f =>
          new Date(f.ds).toLocaleDateString("en-US", { month: "short", year: "numeric" })
        ),
        datasets: [
          {
            label: "Forecast",
            data: data.forecast.map(f => f.yhat),
            borderColor: "#f26523",
            borderWidth: 2,
            tension: 0.3,
            fill: false,
          },
          {
            label: "Confidence Interval (Upper)",
            data: data.forecast.map(f => f.yhat_upper),
            backgroundColor: "rgba(242,101,35,0.1)",
            borderColor: "rgba(242,101,35,0)",
            fill: "+1",
          },
          {
            label: "Confidence Interval (Lower)",
            data: data.forecast.map(f => f.yhat_lower),
            backgroundColor: "rgba(242,101,35,0.1)",
            borderColor: "rgba(242,101,35,0)",
            fill: "-1",
          }
        ]
      },
      options: {
        responsive: true,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { position: "bottom" },
          title: {
            display: true,
            text: `${type.charAt(0).toUpperCase() + type.slice(1)} Forecast`,
            font: { size: 16 }
          }
        },
        scales: {
          x: { ticks: { maxTicksLimit: 12, autoSkip: true } },
          y: { beginAtZero: true }
        }
      }
    });
  } catch (err) {
    console.error(`‚ùå Forecast error for ${type}:`, err);
    document.getElementById(noteId).textContent = "‚ö†Ô∏è Forecast unavailable.";
  }
}

// üßÆ Forecast Summary Cards Updater
async function updateForecastSummaries() {
  try {
    const resSales = await fetch("/api/predict/sales?horizon=30");
    const resBookings = await fetch("/api/predict/bookings?horizon=30");
    const dataSales = await resSales.json();
    const dataBookings = await resBookings.json();

    console.log("Sales Forecast Data:", dataSales);
    console.log("Bookings Forecast Data:", dataBookings);

    // üí∞ Projected Sales (next 30 days)
    if (dataSales.success && dataSales.forecast?.length) {
      const totalSales = dataSales.forecast.reduce((sum, f) => sum + (f.yhat || 0), 0);
      document.getElementById("projectedSales").textContent =
        `‚Ç±${totalSales.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
    } else {
      document.getElementById("projectedSales").textContent = "‚Ç±0";
    }

    // üß≥ Projected Bookings (next 30 days)
    if (dataBookings.success && dataBookings.forecast?.length) {
      const totalBookings = dataBookings.forecast.reduce((sum, f) => sum + (f.yhat || 0), 0);
      document.getElementById("projectedBookings").textContent =
        Math.round(totalBookings).toLocaleString();
    } else {
      document.getElementById("projectedBookings").textContent = "0";
    }

    // üìà Forecast Confidence
    const avgMAPE = ((dataSales.mape || 0) + (dataBookings.mape || 0)) / 2;
    const confidence =
      avgMAPE <= 5 ? "‚úÖ Excellent" :
      avgMAPE <= 15 ? "üüß Good" :
      "üî¥ Needs Improvement";

    document.getElementById("forecastConfidence").textContent = confidence;
  } catch (err) {
    console.error("‚ùå Summary update failed:", err);
  }
}

// üèÅ Load Everything When Page Loads
window.addEventListener("DOMContentLoaded", async () => {
  const horizon = 180; // 6 months

  await loadForecast("sales", "salesForecastChart", "salesForecastAccuracy", "salesForecastNote", horizon);
  await loadForecast("users", "userForecastChart", "userForecastAccuracy", "userForecastNote", horizon);
  await loadForecast("bookings", "bookingForecastChart", "bookingForecastAccuracy", "bookingForecastNote", horizon);

  // Update summary cards after main charts finish loading
  updateForecastSummaries();
});
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  const horizon = 180; // 6 months
  loadForecast("sales", "salesForecastChart", "salesForecastAccuracy", "salesForecastNote", horizon);
  loadForecast("users", "userForecastChart", "userForecastAccuracy", "userForecastNote", horizon);
  loadForecast("bookings", "bookingForecastChart", "bookingForecastAccuracy", "bookingForecastNote", horizon);
});
async function loadForecast(metric, chartId, accuracyId, noteId, horizon) {
  try {
    const response = await fetch("http://127.0.0.1:8000/predict", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        series: await getTimeSeries(metric),
        horizon: horizon
      })
    });

    const data = await response.json();
    if (!data.success) throw new Error(data.error || "Forecast failed.");

    document.getElementById(accuracyId).textContent = `MAPE: ${data.mape}% | RMSE: ${data.rmse}`;
    document.getElementById(noteId).textContent = `${data.trend_note} ${data.seasonality_note}`;
    
    // üîπ Update summary cards if they exist
    if (metric === "sales") {
      document.getElementById("projectedTotalSales").textContent = 
        "‚Ç±" + Math.round(data.forecast.slice(-30).reduce((a, b) => a + b.yhat, 0)).toLocaleString();
      document.getElementById("salesGrowthNote").textContent = data.trend_note || "Stable sales";
    }
    if (metric === "bookings") {
      document.getElementById("projectedTotalBookings").textContent =
        Math.round(data.forecast.slice(-30).reduce((a, b) => a + b.yhat, 0));
      document.getElementById("bookingsTrendNote").textContent = data.trend_note || "Stable bookings";
    }
    if (metric === "users") {
      document.getElementById("projectedTotalUsers").textContent =
        Math.round(data.forecast.slice(-30).reduce((a, b) => a + b.yhat, 0)) + " new";
      document.getElementById("userGrowthNote").textContent = data.trend_note || "Stable user growth";
    }

    renderForecastChart(chartId, data.forecast);
  } catch (err) {
    console.error("Forecast error:", err);
    document.getElementById(noteId).textContent = "‚ùå Forecast unavailable";
  }
}


async function getTimeSeries(metric) {
  const res = await fetch(`/api/timeseries/${metric}`); // You‚Äôll need to create this route in app.js
  return await res.json();
}

function renderForecastChart(chartId, forecast) {
  const ctx = document.getElementById(chartId).getContext("2d");
  const labels = forecast.map(f => f.ds);
  const values = forecast.map(f => f.yhat);
  
  new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [{
        label: "Forecast",
        data: values,
        borderColor: "#f26523",
        fill: false,
        tension: 0.3
      }]
    }
  });
}

</script>

<script>
// ===============================================
// üìà ADVANCED AI DASHBOARD CHARTS & INSIGHTS
// ===============================================

// Reuse Chart.js
const chartColors = {
  sales: '#f97316',
  bookings: '#2563eb',
  users: '#16a34a'
};

// Helper: Create Chart
function makeChart(ctxId, label, labels, data, color) {
  const ctx = document.getElementById(ctxId).getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label,
        data,
        borderColor: color,
        backgroundColor: color + '33',
        fill: true,
        tension: 0.3,
        borderWidth: 2,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      plugins: { legend: { display: false }},
      scales: {
        x: { ticks: { color: '#555' }},
        y: { ticks: { color: '#555' }}
      }
    }
  });
}

// ------------------------------------------------
// üß† Load AI Insights (Recommendations + Top Tours)
// ------------------------------------------------
async function loadAIInsights() {
  try {
    const res = await fetch("/api/admin/tours-performance");
    const tourData = await res.json();

    const response = await fetch("http://127.0.0.1:8000/insights", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tours: tourData })
    });

    const data = await response.json();
    if (data.success) {
      document.getElementById("aiRecommendations").innerHTML =
        data.recommendations.map(r => `<p>${r}</p>`).join("");
      buildTopTourCharts(data.summary.top_revenue_tours);
      updateEmergingDecliningTours(data);
    }
  } catch (err) {
    console.error("AI Insights Error:", err);
  }
}
// Parse Emerging and Declining Tours from recommendations
function updateEmergingDecliningTours(data) {
  const emergingMatch = data.recommendations.find(r => r.includes("üå± Emerging Tours"));
  const decliningMatch = data.recommendations.find(r => r.includes("‚ö†Ô∏è Underperforming Tours"));

  const emergingTours = emergingMatch
    ? emergingMatch.replace("üå± Emerging Tours (rapid growth): ", "").split(", ")
    : [];
  const decliningTours = decliningMatch
    ? decliningMatch.replace("‚ö†Ô∏è Underperforming Tours: ", "").split(", ")
    : [];

  const emergingEl = document.getElementById("emergingToursList");
  const decliningEl = document.getElementById("decliningToursList");

  emergingEl.innerHTML = emergingTours.length
    ? emergingTours.map(t => `<li>${t}</li>`).join("")
    : "<li>No emerging tours found</li>";

  decliningEl.innerHTML = decliningTours.length
    ? decliningTours.map(t => `<li>${t}</li>`).join("")
    : "<li>No declining tours found</li>";
}

// ------------------------------------------------
// üß© Build Charts: Top Tours & Emerging/Declining
// ------------------------------------------------
function buildTopTourCharts(topTours) {
  if (!topTours || !topTours.length) return;

  // Top 5 Tours Bar Chart
  const ctxTop = document.getElementById("topToursChart").getContext("2d");
  new Chart(ctxTop, {
    type: "bar",
    data: {
      labels: topTours.map(t => t.title || t.tourId),
      datasets: [{
        label: "Revenue (‚Ç±)",
        data: topTours.map(t => t.revenue),
        backgroundColor: "#d55a1f99",
        borderColor: "#d55a1f",
        borderWidth: 1
      }]
    },
    options: {
      plugins: { legend: { display: false }},
      scales: {
        x: { ticks: { color: "#333" }},
        y: { ticks: { color: "#333" }}
      }
    }
  });
}
async function buildGrowthComparison() {
  try {
    const res = await fetch("/api/admin/metrics-growth");
    const growth = await res.json(); // { months: [], sales: [], bookings: [] }

    console.log("üìä Growth Data:", growth); // üëÄ Debugging

    const ctx = document.getElementById("growthComparisonChart").getContext("2d");

    new Chart(ctx, {
      type: "line",
      data: {
        labels: growth.months || [],
        datasets: [
          {
            label: "Sales (‚Ç±)",
            data: growth.sales || [],
            borderColor: chartColors.sales,
            backgroundColor: chartColors.sales + "33",
            yAxisID: "ySales",
            tension: 0.3,
            fill: true,
            borderWidth: 2,
          },
          {
            label: "Bookings",
            data: growth.bookings || [],
            borderColor: chartColors.bookings,
            backgroundColor: chartColors.bookings + "33",
            yAxisID: "yBookings",
            tension: 0.3,
            fill: true,
            borderWidth: 2,
          }
        ]
      },
      options: {
        responsive: true,
        interaction: { mode: "index", intersect: false },
        plugins: {
          legend: { position: "bottom" },
          title: {
            display: true,
            text: "Sales vs Bookings Growth",
            font: { size: 16 }
          }
        },
        scales: {
          x: {
            ticks: { color: "#333" }
          },
          ySales: {
            type: "linear",
            position: "left",
            title: { display: true, text: "Sales (‚Ç±)" },
            ticks: {
              color: chartColors.sales,
              callback: (v) => "‚Ç±" + (v / 1000000).toFixed(1) + "M"
            }
          },
          yBookings: {
            type: "linear",
            position: "right",
            title: { display: true, text: "Bookings" },
            grid: { drawOnChartArea: false },
            ticks: { color: chartColors.bookings }
          }
        }
      }
    });
  } catch (err) {
    console.error("‚ùå Growth Chart Error:", err);
  }
}
async function buildSeasonalForecast() {
  try {
    const res = await fetch("/api/admin/seasonal-data");
    const data = await res.json();
    if (!data.success) throw new Error("Failed to load seasonal data");

    const select = document.getElementById("destinationSelect");
    const summary = document.getElementById("peakSeasonSummary");
    const ctx = document.getElementById("seasonalDemandChart").getContext("2d");
    let seasonalChart;

    const destinations = Object.keys(data.datasets);
    select.innerHTML = destinations
      .map(dest => `<option value="${dest}">${dest}</option>`)
      .join("");

    async function updateChart(destination) {
      const series = data.datasets[destination];
      const response = await fetch("http://127.0.0.1:8000/predict", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ series, horizon: 365 })
      });
      const forecast = await response.json();
      if (!forecast.success) throw new Error("Prediction failed");

      const labels = forecast.forecast.map(f =>
        new Date(f.ds).toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric"
        })
      );
      const values = forecast.forecast.map(f => f.yhat);

      // üèî Find the highest value and its date
      const maxIndex = values.indexOf(Math.max(...values));
      const peakDate = labels[maxIndex];
      const peakValue = values[maxIndex].toLocaleString();

      // ü™Ñ Update summary text
      summary.textContent = `üåü Peak Season for ${destination}: ${peakDate} ‚Äî Highest predicted demand (${peakValue} bookings)`;

      // üîÑ Destroy existing chart if it exists
      if (seasonalChart) seasonalChart.destroy();

      // üìä Draw new chart
      seasonalChart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: `${destination} Seasonal Demand`,
              data: values,
              borderColor: "#f26523",
              backgroundColor: "rgba(242, 101, 35, 0.2)",
              borderWidth: 2,
              tension: 0.3,
              fill: true,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                label: ctx => ` ${ctx.formattedValue} bookings`
              }
            },
            annotation: {
              annotations: {
                peakLine: {
                  type: "line",
                  xMin: maxIndex,
                  xMax: maxIndex,
                  borderColor: "#f26523",
                  borderWidth: 2,
                  label: {
                    content: `Peak: ${peakDate}`,
                    enabled: true,
                    position: "start"
                  }
                }
              }
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: "Predicted Bookings"
              }
            }
          }
        }
      });
    }

    // üß† Auto-select destination with highest total demand
    const totals = destinations.map(dest => {
      const sum = data.datasets[dest].reduce((a, b) => a + b.y, 0);
      return { dest, total: sum };
    });
    const topDestination = totals.reduce((a, b) => (a.total > b.total ? a : b)).dest;
    select.value = topDestination;

    // Load top destination first
    updateChart(topDestination);

    // Allow switching between destinations
    select.addEventListener("change", e => updateChart(e.target.value));

  } catch (err) {
    console.error("Seasonal forecast error:", err);
  }
}

// ------------------------------------------------
// üë• User Growth Chart (Historical + Predictive)
// ------------------------------------------------
async function buildUserGrowthChart() {
  try {
    const res = await fetch("/api/admin/user-growth");
    const data = await res.json();

    // Send user data to FastAPI for predictive forecast
    const series = data.months.map((m, i) => ({
      ds: m + "-01", // convert YYYY-MM ‚Üí YYYY-MM-01
      y: data.counts[i]
    }));

    const forecastRes = await fetch("http://127.0.0.1:8000/predict", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ series, horizon: 90 })
    });
    const forecastData = await forecastRes.json();

    if (forecastData.success) {
      const labels = forecastData.forecast.map(f => f.ds);
      const values = forecastData.forecast.map(f => f.yhat);

      makeChart("timeBasedUsersChart", "User Signups (Forecasted)", labels, values, "#16a34a");

      // Update insight cards
      document.getElementById("projectedTotalUsers").textContent =
        Math.round(values.slice(-30).reduce((a, b) => a + b, 0)) + " new";
      document.getElementById("userGrowthNote").textContent =
        forecastData.trend_note || "Stable user trend";
    }
  } catch (err) {
    console.error("User Growth Chart Error:", err);
  }
}
// ------------------------------------------------
// üîÅ User Retention Chart (Historical + Predictive)
// ------------------------------------------------
async function buildUserRetentionChart() {
  try {
    const res = await fetch("/api/admin/user-retention");
    const data = await res.json();

    // Draw retention chart
    const ctx = document.getElementById("userRetentionChart").getContext("2d");
    new Chart(ctx, {
      type: "line",
      data: {
        labels: data.months,
        datasets: [
          {
            label: "User Retention (%)",
            data: data.retentionRate,
            borderColor: "#8b5cf6",
            backgroundColor: "#8b5cf633",
            fill: true,
            tension: 0.4,
            pointRadius: 0
          }
        ]
      },
      options: {
        responsive: true,
        plugins: { legend: { display: false }},
        scales: {
          y: {
            beginAtZero: true,
            max: 100,
            title: { display: true, text: "Retention %" },
            ticks: { color: "#555" }
          },
          x: { ticks: { color: "#555" }}
        }
      }
    });

    // ‚úÖ Calculate & display forecast confidence
    const latestRetention = data.retentionRate.slice(-1)[0];
    const confidenceText = `${latestRetention.toFixed(1)}% Active Users`;

    // Update both summary and AI cards if they exist
    ["forecastConfidenceAI", "forecastConfidenceSummary"].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = confidenceText;
    });

    // Add descriptive note based on confidence level
    const confidenceNote = document.getElementById("confidenceNote");
    if (confidenceNote) {
      confidenceNote.textContent =
        latestRetention >= 80
          ? "üíé Excellent user loyalty"
          : latestRetention >= 60
          ? "üü¢ Good retention ‚Äî keep engagement"
          : "üî¥ Needs improvement ‚Äî many users drop off";
    }

  } catch (err) {
    console.error("User Retention Chart Error:", err);

    // Graceful fallback for UI
    ["forecastConfidenceAI", "forecastConfidenceSummary"].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = "N/A";
    });

    const note = document.getElementById("confidenceNote");
    if (note) note.textContent = "‚ö†Ô∏è Unable to compute forecast confidence.";
  }
}

// ------------------------------------------------
// üë• Load User Engagement Summary
// ------------------------------------------------
async function loadUserEngagement() {
  try {
    const res = await fetch("/api/admin/user-engagement");
    const data = await res.json();

    document.getElementById("activeUsers7").textContent = data.active7Days;
    document.getElementById("activeUsers30").textContent = data.active30Days;
    document.getElementById("retentionRate").textContent = data.retentionRate + "%";
  } catch (err) {
    console.error("User Engagement Summary Error:", err);
    document.getElementById("activeUsers7").textContent = "Error";
    document.getElementById("activeUsers30").textContent = "Error";
    document.getElementById("retentionRate").textContent = "--";
  }
}
// ------------------------------------------------
// üìä User Engagement Trend Chart
// ------------------------------------------------
async function buildUserEngagementTrend() {
  try {
    const res = await fetch("/api/admin/user-engagement-trend");
    const data = await res.json();

    const ctx = document.getElementById("userEngagementTrendChart").getContext("2d");

    new Chart(ctx, {
      type: "bar",
      data: {
        labels: data.months,
        datasets: [
          {
            type: "bar",
            label: "Active Users",
            data: data.active,
            backgroundColor: "#16a34a88",
            borderColor: "#16a34a",
            borderWidth: 1,
            yAxisID: "y"
          },
          {
            type: "line",
            label: "Retention Rate (%)",
            data: data.retention,
            borderColor: "#8b5cf6",
            backgroundColor: "#8b5cf633",
            yAxisID: "y1",
            tension: 0.3,
            fill: false
          }
        ]
      },
      options: {
        responsive: true,
        interaction: { mode: "index", intersect: false },
        stacked: false,
        plugins: {
          legend: { position: "bottom" },
          title: { display: false }
        },
        scales: {
          y: {
            type: "linear",
            position: "left",
            title: { display: true, text: "Active Users" },
            ticks: { color: "#444" }
          },
          y1: {
            type: "linear",
            position: "right",
            title: { display: true, text: "Retention (%)" },
            min: 0,
            max: 100,
            grid: { drawOnChartArea: false },
            ticks: { color: "#8b5cf6" }
          },
          x: {
            ticks: { color: "#555" }
          }
        }
      }
    });
  } catch (err) {
    console.error("User Engagement Trend Error:", err);
  }
}
// ------------------------------------------------
// üë• Load User Activity Insights
// ------------------------------------------------
async function loadUserActivity() {
  try {
    const res = await fetch("/api/admin/user-activity");
    const data = await res.json();

    document.getElementById("activityTotalUsers").textContent = data.totalUsers;
    document.getElementById("activityActiveCount").textContent = data.activeCount;
    document.getElementById("activityInactiveCount").textContent = data.inactiveCount;

    const activeList = document.getElementById("mostActiveUsers");
    const inactiveList = document.getElementById("inactiveUsers");

    activeList.innerHTML = data.activeUsers.length
      ? data.activeUsers.map(u =>
          `<li>${u.firstName || ''} ${u.lastName || ''} ‚Äî <small>${u.email}</small><br><em>Last active: ${new Date(u.lastActiveAt).toLocaleString()}</em></li>`
        ).join("")
      : "<li>No recent active users</li>";

    inactiveList.innerHTML = data.inactiveUsers.length
      ? data.inactiveUsers.map(u =>
          `<li>${u.firstName || ''} ${u.lastName || ''} ‚Äî <small>${u.email}</small><br><em>Last active: ${new Date(u.lastActiveAt).toLocaleDateString()}</em></li>`
        ).join("")
      : "<li>All users active recently üéâ</li>";

  } catch (err) {
    console.error("User Activity Insights Error:", err);
  }
}


window.addEventListener("DOMContentLoaded", async () => {
  await loadAIInsights();
  await buildGrowthComparison();
  await buildSeasonalForecast();
  await buildUserGrowthChart();
  await buildUserRetentionChart();
  await loadUserEngagement();
  await buildUserEngagementTrend();
  await loadUserActivity();
});


</script>
<script>
// ======================================================
// üåü FINAL FORECAST LOADER (WORKS WITH /api/predict/*)
// ======================================================

// Helper: Safely get value or fallback
const safe = (v, fallback = "--") => (v !== undefined && v !== null ? v : fallback);

// Generic function to fetch forecast for metric
async function fetchForecast(metric) {
  try {
    const res = await fetch(`/api/predict/${metric}`);
    const data = await res.json();
    if (!data.success) {
      console.warn(`‚ùå Forecast fetch failed for ${metric}:`, data.message);
      return null;
    }
    return data;
  } catch (err) {
    console.error(`‚ùå Error fetching forecast for ${metric}:`, err);
    return null;
  }
}

// Function to render forecast info into the dashboard
function renderForecast(metric, data) {
  if (!data) return;

  const accuracyId = `${metric}ForecastAccuracy`;
  const noteId = `${metric}ForecastNote`;

  const accuracyEl = document.getElementById(accuracyId);
  const noteEl = document.getElementById(noteId);

  if (!accuracyEl || !noteEl) return;

  // Display MAPE & RMSE
  accuracyEl.textContent = `MAPE: ${safe(data.mape)}% | RMSE: ${safe(data.rmse)}`;

  // Display notes (trend + seasonality)
  const trend = safe(data.trend_note, "No trend note available");
  const season = safe(data.seasonality_note, "");
  const accuracy = safe(data.accuracy);

  // Pick color/icon based on trend
  let color = "text-orange-500";
  if (trend.includes("Upward") || trend.includes("increasing")) color = "text-green-500";
  else if (trend.includes("Downward") || trend.includes("decreasing")) color = "text-red-500";

  noteEl.innerHTML = `
    <span class="${color}">
      ${trend}<br>${season}<br>
      <strong>${accuracy}</strong>
    </span>
  `;
}

// Main loader to call all forecasts
async function loadAllForecasts() {
  const [sales, users, bookings] = await Promise.all([
    fetchForecast("sales"),
    fetchForecast("users"),
    fetchForecast("bookings"),
  ]);

  renderForecast("sales", sales);
  renderForecast("user", users);
  renderForecast("booking", bookings);
}

// Run when page is loaded
document.addEventListener("DOMContentLoaded", loadAllForecasts);
</script>
<script>
async function loadSeasonalForecast() {
  const year = document.getElementById("seasonal-year").value;
  try {
    const res = await fetch(`/api/analytics/seasonal?year=${year}`);
    const data = await res.json();

    if (!data.success) throw new Error(data.message);
    renderSeasonalCharts(data);
  } catch (err) {
    console.error("‚ùå Failed to load seasonal forecast:", err);
    document.getElementById("predictedBookingsTitle").textContent =
      "‚ùå Failed to load seasonal forecast.";
  }
}

function renderSeasonalCharts(data) {
  // üßπ Destroy old charts if reloading
  if (window.seasonalActualChart) window.seasonalActualChart.destroy();
  if (window.seasonalPredictedChart) window.seasonalPredictedChart.destroy();

  // üìä Chart 1: Actual Bookings
  const ctxActual = document.getElementById("seasonalTrendsChart").getContext("2d");
  window.seasonalActualChart = new Chart(ctxActual, {
    type: "bar",
    data: {
      labels: data.months,
      datasets: [
        {
          label: "Actual Bookings",
          data: data.actual,
          backgroundColor: "rgba(37, 99, 235, 0.6)",
          borderColor: "#2563eb",
          borderWidth: 1,
        },
      ],
    },
    options: {
      plugins: {
        title: {
          display: true,
          text: `üìä Actual Bookings (${document.getElementById("seasonal-year").value})`,
        },
        legend: { display: false },
      },
      scales: { y: { beginAtZero: true } },
    },
  });

  // üìà Chart 2: Prophet Forecasted Bookings
  const ctxPredicted = document.getElementById("predictedBookingsChart").getContext("2d");
  window.seasonalPredictedChart = new Chart(ctxPredicted, {
    type: "line",
    data: {
      labels: data.predictedMonths,
      datasets: [
        {
          label: "Predicted Bookings",
          data: data.predicted,
          borderColor: "#f26523",
          backgroundColor: "rgba(242, 101, 35, 0.15)",
          tension: 0.3,
          fill: true,
        },
      ],
    },
    options: {
      plugins: {
        title: {
          display: true,
          text: `üîÆ Forecasted Bookings (Next Year) | MAPE: ${data.mape.toFixed(2)}% | RMSE: ${data.rmse.toFixed(2)}`,
        },
      },
      scales: { y: { beginAtZero: true } },
    },
  });
}

// ‚öôÔ∏è Setup year dropdown & auto-load
window.addEventListener("DOMContentLoaded", () => {
  const currentYear = new Date().getFullYear();
  const select = document.getElementById("seasonal-year");

  for (let y = currentYear - 2; y <= currentYear; y++) {
    const opt = document.createElement("option");
    opt.value = y;
    opt.textContent = y;
    if (y === currentYear) opt.selected = true;
    select.appendChild(opt);
  }

  // Load default data on load
  loadSeasonalForecast();
});

document.getElementById("seasonal-apply").addEventListener("click", loadSeasonalForecast);
</script>
<script>
document.getElementById("exportDashboardExcel").addEventListener("click", async () => {
  try {
    const res = await fetch("/api/admin/export-dashboard");
    if (!res.ok) throw new Error("Export failed");

    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "A.BEE_Admin_Report.xlsx";
    a.click();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Export error:", err);
    alert("‚ö†Ô∏è Failed to export report. Please try again.");
  }
});
</script>

</body>
</html>
